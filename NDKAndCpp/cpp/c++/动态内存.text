C++ 程序中的内存分为两个部分：

栈：在函数内部声明的所有变量都将占用栈内存。
堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。


很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。
在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。
如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存
new data-type;
delete data-type;

Student a; //由操作系统进行内存的分配和管理
Student a = new Student(); //堆中分配，由管理者进行内存的分配和管理，用完必须delete()，否则可能造成内存泄漏

数组
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]
回收内存
delete [] pvalue;
指针判空
if(p != nullptr)

malloc与new的区别
malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象


空指针和野指针
https://www.cnblogs.com/lianjiehere/p/5129363.html
空指针常量
一个表示0值的整数常量，叫做空指针常量。例如：0、0L、1-1（它们都是值为0的整数常量表达式）以及(void*)0、void* NULL 都是空指针常量，
空指针常量可以赋值给任何指针类型，因为它是变体类型（void*）。但是我们更倾向于使用NULL表示这个空指针常量。
对于其它方式（比如0）来表示空指针常量虽然不会产生任何问题，但是在根本意义上并不符合空指针常量的定义。因为空指针常量的存在意义还在强调它并不指向任何对象

空指针
空指针不指向任何实际的对象或者函数。反过来说，任何对象或者函数的地址都不可能是空指针 。
空指针是一个特殊的指针，因为这个指针不指向任何地方。这意味任何一个有效的指针如果和空指针进行相等的比较运算时，结果都是false。
在程序中，得到一个空指针最直接的方法就是运用预定义的NULL，这个值在多个头文件中都有定义。
如果要初始化一个空指针，我们可以这样，
int *ip = NULL;

NULL指针
NULL是一个标准规定的宏定义，用来表示空指针常量。在C++里面被直接定义成了整数立即数的0，而在没有__cplusplus定义的前提下，
就被定义成一个值是0的 void* 类型的指针常量

零指针
零值指针，是值为0的指针，可以是任何一种类型的指针，可以是通用变体类型 void*，也可以是 char*， int* 等等。
在C++里面，任何一个概念都以一种语言内存公认的形式表现出来，例如std::vector会提供一个empty()子函数来返回容器是否为空，
然而对于一个基本数值类型（或者说只是一个类似整数类型的类型）我们不可能将其抽象成一个类（当然除了auto_ptr等智能指针）来提供其详细的状态说明，
所以我们需要一个特殊值来做为这种状态的表现。

C++标准规定，当一个指针类型的数值是0时，认为这个指针是空的。（我们在其它的标准下或许可以使用其它的特殊值来定义我们需要的NULL实现，
可以是1，可以是2，是随实现要求而定的，但是在标准C++下面我们用0来实现NULL指针）

野指针
野指针不是空指针，是一个指向垃圾内存的指针。

形成原因
1.指针变量没有被初始化。
任何指针变量被刚创建时不会被自动初始化为NULL指针，它的缺省值是随机的。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL
，要么让它指向合法的内存。例如：
char* p = NULL;
char* str = (char*)malloc(1024);

2.指针被free或者delete之后，没有设置为NULL，让人误以为这是一个合法指针。
free和delete只是把指针所指向的内存给释放掉，但并没有把指针本身给清理掉。这时候的指针依然指向原来的位置，只不过这个位置的内存数据已经被毁尸灭迹，
此时的这个指针指向的内存就是一个垃圾内存。但是此时的指针由于并不是一个NULL指针（在没有置为NULL的前提下），在做如下指针校验的时候
if(p != NULL)
会逃过校验，此时的p不是一个NULL指针，也不指向一个合法的内存块，造成会面程序中指针访问的失败。

3.指针操作超越了变量的作用范围。
由于C/C++中指针有++操作，因而在执行该操作的时候，稍有不慎，就容易指针访问越界，访问了一个不该访问的内存，结果程序崩溃
另一种情况是指针指向一个临时变量的引用，当该变量被释放时，此时的指针就变成了一个野指针，如下
A *p; // A为一个自定义对象
 {
     A a;
     p = &a; // 注意 a 的生命期 ，只在这个程序块中（花括号里面的两行），而不是整个test函数
  }
  p->Func();  // p是“野指针”