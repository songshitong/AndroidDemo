https://juejin.cn/post/7082320749977042980

jpeg算法
https://www.thecodeway.com/?p=69

https://github.com/nihui/opencv-mobile  提供了opencv的裁剪包(哪些裁剪了)以及编译过程
不提供JavaAPI，包含模块
opencv_core	Mat, matrix operations, etc
opencv_imgproc	resize, cvtColor, warpAffine, etc
opencv_highgui	imread, imwrite
opencv_features2d	keypoint feature and matcher, etc (not included in opencv 2.x package)
opencv_photo	inpaint, etc
opencv_video	opticalflow, etc


https://github.com/HuTianQi/SmartOpenCV  摄像头相关
https://github.com/QuickBirdEng/opencv-android  android gradle集成opencv

官方
https://opencv.org/releases/
https://github.com/opencv/opencv/tree/master
https://learnopencv.com/getting-started-with-opencv/

中文文档
https://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html


文字识别  opencv处理图片，tesseract识别文字 
https://github.com/adaptech-cz/Tesseract4Android   不支持Tesseract OCR
PaddleOCR


https://www.bilibili.com/video/BV1JX4y1u7kV/?vd_source=16dbd3bff220c5634a2dd63f05cc4ea1 入门教程



https://my.oschina.net/u/5255792/blog/5138026
游戏识别
https://my.oschina.net/u/4532295/blog/5537420 大家来找茬示例


https://github.com/Tencent/GameAISDK   微信AI检测，基于pc

https://zhuanlan.zhihu.com/p/269215933/ 游戏色块检测以及基础介绍


//todo
按键精灵    连招操作，通过配置一直按一个键达到刷图的目的，只需操控任务即可

内存挂  直接修改游戏内存 https://zhuanlan.zhihu.com/p/490189706  
1  virtual X driver
2 ToolHelp API
3 利用游戏进程的对应函数  例如利用：ReadProcessMemory 和 WriteProcess-Memory 两个函数对游戏进程进行读取和写入

窜改网络数据的“封包挂”“协议挂”
外挂制作者利用封包截取工具截取通信数据包，经过多次截取封包，分析数据，得到封包数据对应的人物操作或属性
网络游戏的前期由于其服务器功能的限制，一般封包都不加密或者采用异或加密很好破解，修改对应的数据，再利用封包截获工具转发给服务器，
  通过篡改通信数据来实现作弊。WPE是外挂玩家常用的封包编辑工具

其他类型的挂
显卡驱动级别的外挂，直接修改显卡驱动。
硬件外挂。定制鼠标芯片、鼠标高级宏、定制键盘或机械手等。
AI外挂。基于深度学习、强化学习的人工智能外挂。表现形式类似模拟挂。

检测外挂的常见方法
（1）变量检测。设置一个全局变量。在游戏关键功能函数的外层函数赋值，在功能函数内部检测。正常游戏调用肯定是一步一步执行的，必然会对变量赋值，
但是游戏外挂会直接调用功能函数，函数内部发现变量没有被赋值，而检测到外挂。
（2）堆栈检测。变量检测有一个弱点，那就是必须设置一个全局变量来传递信息，有可能被外挂作者利用内存扫描工具来回扫描发现变量，在调用前提前赋值规避检测。
堆栈检测避免了这一点，实现原理是在游戏功能函数内部读取堆栈信息，以此得到调用函数的代码来源，如果发现并非正常代码调用的堆栈，那就是外挂程序了。
（3）数据检测。不断读取关键数据以查看是否被外挂篡改，不过直接查看太过容易被外挂作者发现，一般混在游戏正常读取数据的代码中间接查看是否异常。
（4）CRC检测。CRC检测主要是保护游戏代码不被外挂程序篡改，游戏中有一些关键逻辑代码，比如如果血量为0的话会判断人物死亡，外挂课程可以恶意篡改判断逻辑，
让程序无论怎样都不会执行死亡代码，从而实现无敌效果。CRC检测的原理是，不断的读取关键代码的值，以此查看代码是否被篡改。C
RC之类算法对自身的完整效验勾挂函数的完整效验，一些重要代码段另外单独校验，校验相关代码段VMP，必要的话返回服务器中验证。
（5）进程检测。获取系统进程列表，检测是否有常见外挂的进程名，如果检测到存在外挂进程。直接强制下线。
（6）行为检测。现在大力发展的新兴检测 如某企鹅的DXF就有此保护机制 效果甚好 甚至连图色辅助都无法在其幸存 搞得 一些人直接上机械臂，与上面几种方式不同：
此种检测主要是检测用户的行为，主要是利用深度学习人工智能大数据对玩家的行为数据进行分析。比如一局游戏中一位玩家爆头和击杀率都特别的高，
鼠标移动的轨迹几乎为直线，那么就可以把这些数据异常的玩家抽调出来转入人工检测，或者极为异常的直接封号处理。

防篡改思路
（1）游戏登陆相关封包处理。游戏的登录封包尽量复杂化，不同的封包类型中部分数据采用多重加密是必要的，多个端口乱序通讯，
这些登陆分包是一次性的不用太担心算法效率问题，而此操作却可以大大增加逆向难度。
（2）游戏反调试保护。主流思想是驱动层进行调试器进程检测、标志位检测，HOOK重要函数等方法以及给游戏执行文件加猛壳利用壳的功能实现反调。
（3）服务器数据校验。收到客户端发来的消息后，对消息的合法性进行验算。比如上面提到的秒通关封包漏洞。服务器可以针对战斗数据做校验来进一步判断是否真的通关成功。
（4）快速小规模更新游戏。更新内容是代码混淆，基址变更。
（5）协议非对称加密交换密钥，对称加密传输内容，保护好服务端私钥，防止中间人攻击。流式加密，同样包发两次内容不一样。
（6）不定期弹出反外挂答题，答正确奖励经验，错误就掉线。
（7）客户端加密加壳防止调试和注入，程序签名防止篡改二进制。
（8）重要代码放虚拟机或者脚本里运行（脚本字节码需需改），一般黑客主要分析反汇编，复杂逻辑多套几层黑客就晕了。
（9）关键数据不落内存，一律使用getxx，setxx之类的接口，后面将真实数据经过变换以后才落内存。
（10）守护进程动态跟踪监控情况。
（11）决定性逻辑永远放在服务端。
（12）发现某黑客/外挂工具利用某漏洞破解了游戏，先看影响大不大，再看他挣不挣钱，影响一般又不挣钱的话可以先养着他，等他挣钱了用户多了，
大型活动之前，一条指令就把它封了，用户退款都可以弄得他爬不起来。
（13）必须要放在客户端计算的逻辑将输入和结果hash同步给其他客户端验算，不对就踢掉。
（14）当检测到客户端触碰到某规则不要急着踢掉它，而是有概率踢掉，还要随机几秒踢掉，这样黑客发现一会这里断一会那里断，就蒙圈了。