



https://blog.csdn.net/jia4525036/article/details/18982197
viewPager常用属性
1）mViewPager.setOffscreenPageLimit(2);//设置缓存view 的个数（实际有3个，缓存2个+正在显示的1个）
2）mViewPager.setPageMargin((int)getResources().getDimensionPixelOffset(R.dimen.ui_5_dip));//设置viewpager每个页卡的间距，与gallery的spacing属性类似
3）ViewPager更新数据问题：






给文字设置图片，实现一些特殊效果，例如点这里搜索🔍 U+1F50D  放大镜
TextView tv;
tv.setCompoundDrawables();
文字超长显示点点 https://blog.csdn.net/sinat_38184748/article/details/90181546
// 在字符串最后显示省略号
android:ellipsize="end"
// 在字符串开始显示省略号
android:ellipsize="start"
// 在字符串中间显示省略号
android:ellipsize="middle"
// 以跑马灯的方式显示(动画横向移动)显示省略号
android:ellipsize="marquee"
EditText
光标最后 setSelection(int index) 能够设置光标的位置；
输入间隔符 手机号，银行卡号
   自己判断拿到string+空格再设置回去
监听软键盘删除键
```
EditTextPhone.setOnKeyListener(new View.OnKeyListener() {
      @Override
      public boolean onKey(View v, int keyCode, KeyEvent event) {
        int action = event.getAction();
        if(keyCode == KeyEvent.KEYCODE_DEL&&action == KeyEvent.ACTION_DOWN) {
        }
        return false;
      }
    });
```


https://stackoverflow.com/questions/2658772/vertical-line-using-xml-drawable?answertab=trending#tab-top
画横线，竖线
```
<View
    android:layout_width="1dp"
    android:layout_height="match_parent"
    android:background="#FF0000FF" />
<View
    android:layout_width="match_parent"
    android:layout_height="1dp"
    android:background="#FF0000FF" />    
```
阴影xml
android:shadowDx="0"
android:shadowDy="2"
android:shadowColor="@color/shadow_142a7bff"


文字带一个图标
drawablePadding图标与文字间距
```
<TextView
        android:drawablePadding="11" 
        android:drawableRight="@drawable/login_arrow_right"/>
```
代码实现参考https://github.com/MrFuFuFu/ClearEditText  目前没法自由调整icon位置，只能在固定的left,top,right,bottom



Space标签
Space是一个轻量级的View子类，通常将其用于创建组件之间间隙的目的，也可以辅助ConstraintLayout定位等
```
<Space
        android:id="@+id/space"
        />
```





https://blog.csdn.net/Lindroid20/article/details/72551102
EditText下划线
去掉：android:background="@null"
textCursorDrawable 光標的顔色，樣式  @null去掉光标
android:cursorVisible 光標是否顯示
改变下划线颜色，使用主题形式
```
<style name="LoginEditText">
        <item name="colorControlNormal">@color/black_606266</item>
        <item name="colorControlActivated">@color/black_606266</item>
        <item name="colorControlHighlight">@color/black_606266</item>
    </style>
 //使用   
 android:theme="@style/LoginEditText"    
```


https://www.jianshu.com/p/8fb40cb7fced
一般定义在res/values/styles.xml文件中  可以用来制作统一样式，使用样式可以指定多个控件具有的重复属性统一抽取出来进行编写
<style>通过添加多个<item>来设置样式不同的属性。另外，样式是可以继承的，可通过<style>标签的parent属性声明要继承的样式
  如果使用父主题样式，要更改许多父主题的样式
如果属性是name主题里面的直接写就可以，如果是Android，使用android命名空间；自定义属性使用包名"com.mobeta.android.dslv.view:drawableSize"
//下面这个例子其实包含了主题的写法
```
<style name="Widget.Material.Button" parent="Widget.MaterialComponents.Button">
      <item name="com.mobeta.android.dslv.view:drawableSize">@dimen/dp20</item>
      <item name="android:textAppearance">@style/TextAppearance.App.Button</item>
      <item name="background">@drawable/btn_default_material</item>       
      <item name="textAppearance">?attr/textAppearanceButton</item> 
      <item name="minHeight">48dip</item>
      <item name="minWidth">88dip</item>
      <item name="stateListAnimator">@anim/button_state_list_anim_material</item> 
      <item name="focusable">true</item> 
      <item name="clickable">true</item>
      <item name="gravity">center_vertical|center_horizontal</item>
//<\/style>
```

使用
```
<Button 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:onClick="onAction" 
        android:text="@string/btn_action"   
        style="@style/Widget.Material.Button" />
```

主题
主题是包含一种或多种的格式化属性集合，在程序中调用主题资源可改变窗体的样式，对整个应用或某个Activity存在全局性影响。
 定义位置：res/values目录下的styles.xml文件中
 标签
```
<style </style ：定义主题
<item </item ：设置主题的样式
```
 示例（定义一个名为AppTheme的主题）
```
 <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar" 
      <!-- Customize your theme here. -- 
      <item name="colorPrimary" @color/colorPrimary</item 
      <item name="colorPrimaryDark" @color/colorPrimaryDark</item 
      <item name="colorAccent" @color/colorAccent</item 
 </style 
```
主题的使用
  （1）XML文件中：android:theme =”@style/AppTheme”
 （2）Java代码中：setTheme(R.style.AppTheme);

优先级
当theme与样式style发生冲突时，style有效，因为style的优先级高于theme；在R.attr定义中以window开头的一些属性只对theme有效
代码设置style
Button tvButton = new Button(new ContextThemeWrapper(getActivity(),R.style.AccountActionButton));






https://www.jianshu.com/p/59e8006c7cbd
实现富文本  一部分文字不同样式
 //方法一：
        TextView tvValue = findViewById(R.id.tv_value);
        String str="默认颜色<font color='#FF0000'><small>红颜色 
       </small></font>";
        tvValue.setTextSize(18);
        tvValue.setText(Html.fromHtml(str));
方法二：
SpannableStringBuilder spannableString = new SpannableStringBuilder("如果我是陈奕迅");
ForegroundColorSpan foregroundColorSpan1 = new ForegroundColorSpan(Color.GREEN);
ForegroundColorSpan foregroundColorSpan2 = new ForegroundColorSpan(Color.GREEN);
spannableString.setSpan(foregroundColorSpan1, 0, 2, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
spannableString.setSpan(foregroundColorSpan2, 4, 7, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);
mTextView.setText(spannableString);

其他还有BackgroudColorSpan，AbsoluteSizeSpan，UnderlineSpan ，StrikethroughSpan，SuperscriptSpan 



RecyclerView
单击，多选，多选
```
 @Override
    public void onBindViewHolder(@NonNull BasicViewHolder holder, final int position) {}
```
onBindViewHolder的触发时机是view展示时  onBindViewHolder做的事就是把数据绑定到view，view更新-》改变数据-》notify->view更新
onBindViewHolder{
  tv.setText(datas.text)
  tv.click{
     datas[i].text=newText
     notifyItemChanged; //触发新的bindView从而更新view
  }
}
RecyclerView中item有自己的状态可以通过view.setTag()/getTag()保存和获取，这一切都是在onBindViewHolder方法中完成，
  每次方法调用绑定的view是不同的
Flutter中直接构建每个widget，每个widget有自己的状态，可以很方便控制

每次notifyDataChanged，tag都被重置了，需要注意是不是需要  onViewRecycled时也要重置状态
onBinViewHolder{
   playerControl.setTag(R.id.audio_record_play_icon_status,
          AUDIO_RECORD_PLAY_ICON_STATUS_TO_PLAY);
}
建议不要直接更新view，
一是view的复用，view的一些属性没有重用，出现奇怪的问题，
二是直接更新view每次onBindView需要更新时，有些状态容易遗漏(比如在点击事件绑定属性了，但是复用后onBindView就没有了)
建议给item绑定数据，操作数据更新，只更新每一个item对应的数据


给最后一行设置底边距
```
   class AudioRecordItemDecoration extends RecyclerView.ItemDecoration {
   ...
        @Override
        public void getItemOffsets(Rect outRect, View view,
                                   RecyclerView parent, RecyclerView.State state) {

            if (parent.getChildAdapterPosition(view) == parent.getAdapter().getItemCount() - 1) {
                outRect.bottom = 200;
            }
        }
    }
```
recyclerview多布局
https://blog.csdn.net/Picasso_L/article/details/50697844
1.重写RecyclerView.Adapter的getItemViewType(int position),在此方法中根据不同的position，设置不同的ViewType
2.编写具体的RecyclerView.ViewHolder子类(不同子类对应不同View或Layout)
3.重写RecyclerView.Adapter的onCreateViewHolder(ViewGroup parent,int viewType) 在此方法中根据我们之前设置的ViewType来返回不同的RecyclerView.ViewHolder的子类
```
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) {
        RecyclerView.ViewHolder holder = getViewHolderByViewType(viewType);
        //可以配置多种ViewHolder   
        return holder;
    }

private RecyclerView.ViewHolder getViewHolderByViewType(int viewType) {}
@Override
 public int getItemViewType(int position) {}
@Override
 public void onBindViewHolder(RecyclerView.ViewHolder viewHolder, int i) {
```

recyclerView因为动画闪烁
```
binding.audioRecordingRecyclerView.setItemAnimator(null);
```
TODO 不调用notifyItem为什么不能更新view
onclick{
  text.setText
  adapter.notifyItem()  
}
todo  添加的参数干嘛的
adapter.notifyItemChanged(currentPosition,new Object()); 


recyclerView新老位置 分别更新
```
  @Override
  public void onItemClick(ViewGroup parent, View view, Object o, int position) {
    int oldPosition = clickPosition;
    adapter.notifyItemChanged(oldPosition);
    clickPosition = position;
    adapter.notifyItemChanged(position);
  }
```