https://www.jianshu.com/p/65523b2ce15b
https://www.jianshu.com/p/3d52c5ede093

RecyclerView怎么执行ItemAnimator的
1. 概述 动画的动作
   词语	含义
   Disappearance	表示在动画之前，ItemView是可见的，动画之后就可不见了。这里的操作包括，remove操作和普通的滑动导致ItemView划出屏幕
   Appearance	    表示动画之前，ItemView是不可见，动画之后就可见了。这里的操作包括，add操作和普通的滑动导致ItemView划入屏幕
   Persistence	    表示动画前后，状态是不变的。这里面的操作包括，无任何操作
   change	        表示动画前后，状态是不变的。这里面的操作包括，change操作。

还有注意的一点就是，ViewHolder不是用来记录ItemView的位置信息，而是进行数据绑定的，所以在动画中，关于位置信息的记录不是依靠ViewHolder来实现的，
  而是依靠一个叫ItemHolderInfo的类实现的，在这个类里面，有四个成员变量，分别记录ItemView的left、top、right和bottom四个位置信息。
最后还需要注意一点就是，我们从RecyclerView的三大流程中可以得到，在RecyclerView的内部，dispatchLayout分为三步，
  其中dispathchLayoutStep1被称为预布局，在这里主要是保存ItemView的OldViewHolder,同时还会记录下每个ItemView在动画之前的位置信息;
   与之对应的dispathchLayoutStep3被称为后布局，主要结合真正布局和预布局的相关信息来实现进行动画，当然前提是RecyclerView本身支持动画。


运行哪种动画 Simple或Predictive
```
  private void processAdapterUpdatesAndSetAnimationFlags() {
        if (mDataSetHasChangedAfterLayout) {
            mAdapterHelper.reset();
            if (mDispatchItemsChangedEvent) {
                mLayout.onItemsChanged(this);
            }
        }      
        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }
        boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged;
        //运行简单动画
        mState.mRunSimpleAnimations = mFirstLayoutComplete
                && mItemAnimator != null
                && (mDataSetHasChangedAfterLayout
                || animationTypeSupported
                || mLayout.mRequestedSimpleAnimations)
                && (!mDataSetHasChangedAfterLayout
                || mAdapter.hasStableIds());
        //运行复杂动画        
        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
                && animationTypeSupported
                && !mDataSetHasChangedAfterLayout
                && predictiveItemAnimationsEnabled();
    }
```
本文打算从两个角度来分析RecyclerView的动画，一是从普通三大的流程来看，这是动画机制的核心所在；而是从Adapeter的角度上来看，
  看看我们每次在调用Adapter的notify相关方法之后，是怎么进行执行动画的(实际上也是回到三大流程里面)
1. 再来看RecyclerView的三大流程
```
private void dispatchLayoutStep1() {
...
if (mState.mRunSimpleAnimations) {
            // Step 0: Find out where all non-removed items are, pre-layout
            int count = mChildHelper.getChildCount();
            for (int i = 0; i < count; ++i) {
                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) {
                    continue;
                }
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPreLayoutInformation(mState, holder,
                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                                holder.getUnmodifiedPayloads());
                mViewInfoStore.addToPreLayout(holder, animationInfo);
                if (mState.mTrackOldChangeHolders && holder.isUpdated() && !holder.isRemoved()
                        && !holder.shouldIgnore() && !holder.isInvalid()) {
                    long key = getChangedHolderKey(holder);
                    //添加到ViewInfoStore.mOldChangedHolders                   
                    mViewInfoStore.addToOldChangeHolders(key, holder);
                }
            }
        }
        if (mState.mRunPredictiveAnimations) {
            saveOldPositions();
            final boolean didStructureChange = mState.mStructureChanged;
            mState.mStructureChanged = false;
            // temporarily disable flag because we are asking for previous layout
            mLayout.onLayoutChildren(mRecycler, mState);
            mState.mStructureChanged = didStructureChange;

            for (int i = 0; i < mChildHelper.getChildCount(); ++i) {
                final View child = mChildHelper.getChildAt(i);
                final ViewHolder viewHolder = getChildViewHolderInt(child);
                if (viewHolder.shouldIgnore()) {
                    continue;
                }
                if (!mViewInfoStore.isInPreLayout(viewHolder)) {
                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);
                    boolean wasHidden = viewHolder
                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                    if (!wasHidden) {
                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    }
                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(
                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());
                    //添加到ViewInfoStore.mLayoutHolderMap或mOldChangedHolders
                    if (wasHidden) {
                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);
                    } else {
                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);
                    }
                }
            }
            clearOldPositions();
        } else {
            clearOldPositions();
        }
   ...     
}
```
dispatchLayoutStep1方法分为2步
1 找到每个没有被remove 掉的ItemView，将它的ViewHolder(OldViewHolder)放在ViewInfoStore里面，同时还将它预布局的位置放在ViewInfoStore里面。
  这两个信息在后面做动画时都会用到。
2 如果当前RecyclerView的LayoutManager支持predictive item animations(supportsPredictiveItemAnimations方法返回true)，
  会真正的进行预布局。在这一步，会先调用LayoutManager的onLayoutChildren进行一次布局，不过这次布局是预布局，也就是说不是真正的布局，
  只是先确定每个ItemView的位置。预布局之后，此时取到的每个ItemView的ViewHolder和ItemHolderInfo，便是每个ItemView的最终信息。

第二步的信息与第一步的信息相互呼应，第一步是变化前的信息，第二步是变化后的信息。这些都是为dispatchLayout3阶段的动画做准备。其中，
  我们发现相对于第一步，第二步变得复杂了很多。不过，我们可以发现，不管怎么复杂，都是通过调用addToOldChangeHolders方法来保存当前ItemView的ViewHolder
  (在LayoutManager的onLayoutChildren方法前后，在同一个位置上，不一定是同一个ItemView,也不一定是同一个ViewHolder),
  然后调用addXXXLayout方法将位置信息(ItemHolderInfo)保存起来。   将ItemHolderInfo与ViewHolder保存在一起
  addToAppearedInPreLayoutHolders(),addToPreLayout(),addToOldChangeHolders

然后，我们再来看看dispatchLayoutStep3阶段:
```
private void dispatchLayoutStep3() {
...
//将相关信息取到，然后添加到ViewInfoStore
if (mState.mRunSimpleAnimations) {
            for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) {
                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore()) {
                    continue;
                }
                long key = getChangedHolderKey(holder);
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPostLayoutInformation(mState, holder);
                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);
                if (oldChangeViewHolder != null && !oldChangeViewHolder.shouldIgnore()) {
                    final boolean oldDisappearing = mViewInfoStore.isDisappearing(
                            oldChangeViewHolder);
                    final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);
                    if (oldDisappearing && oldChangeViewHolder == holder) {
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                    } else {
                        final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(
                                oldChangeViewHolder);
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                        ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);
                        if (preInfo == null) {
                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);
                        } else {
                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,
                                    oldDisappearing, newDisappearing);
                        }
                    }
                } else {
                    mViewInfoStore.addToPostLayout(holder, animationInfo);
                }
            }

            // 触发动画
            mViewInfoStore.process(mViewInfoProcessCallback);
        }
...
}      
```
跟动画有关的主要有2步
1 获得相关的位置信息(ItemHolderInfo)，然后通过addToPostLayout方法将位置保存在ViewInfoStore里面。
2 调用ViewInfoStore的process方法触发动画。

其中第一步非常容易理解，先是获到当前ItemView的位置信息，保存在ViewInfoStore里面。其中，我们在这里发现，如果OldViewHolder不为空的话，
  会特别处理，为什么会这样处理的呢？其实这里考虑到change操作，因为change操作会涉及到两个ItemView的动画变化，所以，我们发现，
  如果一个ItemView调用的是animateChange方法进行动画开始，而不是走通用的逻辑(将位置信息通过addToPostLayout方法保存起来，
  然后调用process方法进行统一的调用)。
然后就是第二步。我们来看看ViewInfoStore的process方法,不过在我们在这方法之前，我们我们先看看ProcessCallback接口的几个方法。
方法                	作用
processDisappeared	一个ItemView从可见到不可见会回调这个方法，主要是执行这种情况下的动画
processAppeared  	一个ItemView从不可见到可见会回调这个方法。
processPersistent	一个ItemView动画前后状态为改变，这里面包括：本身未发生任何操作的ItemView、change操作的ItemView
unused	           一个ItemView的变化不支持动画会回调此方法，这里包括比如一个ItemView先是Appeared然后disappeared，
                    这种情况RecyclerView找不到合适的动画；还有当前ItemView缺少preInfo，也就是在预布局未记录位置信息，
                    也会调用此方法，这种情况经常是ItemView进行remove操作，但是Adapter调用的是notifyDataSetChanged方法

现在，我们正式的来看看process方法：
```
void process(ProcessCallback callback) {
        for (int index = mLayoutHolderMap.size() - 1; index >= 0; index--) {
            final RecyclerView.ViewHolder viewHolder = mLayoutHolderMap.keyAt(index);
            final InfoRecord record = mLayoutHolderMap.removeAt(index);
            if ((record.flags & FLAG_APPEAR_AND_DISAPPEAR) == FLAG_APPEAR_AND_DISAPPEAR) {
                // Appeared then disappeared. Not useful for animations.
                callback.unused(viewHolder);
            } else if ((record.flags & FLAG_DISAPPEARED) != 0) {
                // Set as "disappeared" by the LayoutManager (addDisappearingView)
                if (record.preInfo == null) {
                    // similar to appear disappear but happened between different layout passes.
                    // this can happen when the layout manager is using auto-measure
                    callback.unused(viewHolder);
                } else {
                    callback.processDisappeared(viewHolder, record.preInfo, record.postInfo);
                }
            } else if ((record.flags & FLAG_APPEAR_PRE_AND_POST) == FLAG_APPEAR_PRE_AND_POST) {
                // Appeared in the layout but not in the adapter (e.g. entered the viewport)
                callback.processAppeared(viewHolder, record.preInfo, record.postInfo);
            } else if ((record.flags & FLAG_PRE_AND_POST) == FLAG_PRE_AND_POST) {
                // Persistent in both passes. Animate persistence
                callback.processPersistent(viewHolder, record.preInfo, record.postInfo);
            } else if ((record.flags & FLAG_PRE) != 0) {
                // Was in pre-layout, never been added to post layout
                callback.processDisappeared(viewHolder, record.preInfo, null);
            } else if ((record.flags & FLAG_POST) != 0) {
                // Was not in pre-layout, been added to post layout
                callback.processAppeared(viewHolder, record.preInfo, record.postInfo);
            } else if ((record.flags & FLAG_APPEAR) != 0) {
                // Scrap view. RecyclerView will handle removing/recycling this.
            } else if (DEBUG) {
                throw new IllegalStateException("record without any reasonable flag combination:/");
            }
            InfoRecord.recycle(record);
        }
    }
```
其实process方法非常简单，就是通过相关的flag来调用ProcessCallback相关的方法。
我们现在来看看ProcessCallback的每个方法都怎么实现的
```
 private final ViewInfoStore.ProcessCallback mViewInfoProcessCallback =
            new ViewInfoStore.ProcessCallback() {
                @Override
                public void processDisappeared(ViewHolder viewHolder, @NonNull ItemHolderInfo info,
                        @Nullable ItemHolderInfo postInfo) {
                    mRecycler.unscrapView(viewHolder);
                    animateDisappearance(viewHolder, info, postInfo);
                }

                @Override
                public void processAppeared(ViewHolder viewHolder,
                        ItemHolderInfo preInfo, ItemHolderInfo info) {
                    animateAppearance(viewHolder, preInfo, info);
                }

                @Override
                public void processPersistent(ViewHolder viewHolder,
                        @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) {
                    viewHolder.setIsRecyclable(false);
                    if (mDataSetHasChangedAfterLayout) {
                        if (mItemAnimator.animateChange(viewHolder, viewHolder, preInfo,
                                postInfo)) {
                            postAnimationRunner();
                        }
                    } else if (mItemAnimator.animatePersistence(viewHolder, preInfo, postInfo)) {
                        postAnimationRunner();
                    }
                }
                @Override
                public void unused(ViewHolder viewHolder) {
                    mLayout.removeAndRecycleView(viewHolder.itemView, mRecycler);
                }
            };
```
其实说到底，就是调用了animateXXX方法来实现，而animateXXX方法里面做了啥？其实没啥,就是调用了ViewCompat的postOnAnimation方法往任务队列后面post一个Runnable。
代码如下：
```
    void postAnimationRunner() {
        if (!mPostedAnimatorRunner && mIsAttached) {
            ViewCompat.postOnAnimation(this, mItemAnimatorRunner);
            mPostedAnimatorRunner = true;
        }
    }
 private Runnable mItemAnimatorRunner = new Runnable() {
        public void run() {
            if (mItemAnimator != null) {
                mItemAnimator.runPendingAnimations();
            }
            mPostedAnimatorRunner = false;
        }
    };    
```
我们需要注意的是，postAnimationRunner每次只会被调用一次。那么如果在某一次操作中，会执行多个动画，怎么办呢？
ProcessCallback每个回调方法都会调用animateXXX方法，而animateXXX方法会调用ItemAnimator对应的方法，在ItemAnimator里面，
会将当前动画添加到一个数组里面，然后通过mItemAnimatorRunner调用ItemAnimator的runPendingAnimations方法，
runPendingAnimations方法就是所有动画开始的起点。这里，我们就不讨论ItemAnimator内部的实现，后面有专门的文章来分析它。


2. 从Adapter角度来看动画执行的机制
   我们知道，调用Adapter的notifyDataSetChanged方法，RecyclerView是不会执行动画的；而调用notifyItemRemoved之类的方法是有动画，
   这里我们从Adapter的角度来分析动画。跟ItemAnimator一样，这里我们也不会去分析Adapter,后面会有专门的文章分析它。
   在分析Adapter之前，我们先来看一个东西，就是RecyclerView和Adapter怎么进行通信。

(1).通过观察者模式来实现RecyclerView 和Adapter的通信
我们思考这个问题之前，首先应该排除Adapter和RecyclerView是强耦合的，也就是说，Adapter内部持有一个RecyclerView对象。
  RecyclerView本身就是插拔式设计，如果Adapter和RecyclerView是强耦合，就违背了插拔式的设计思想。那么它俩究竟是怎么进行通信的呢？
  答案已经非常的明显了，两者是通过观察者模式来进行通信。
这其中，Adapter作为被观察者，RecyclerView作为观察者，当Adapter的数据发生改变时，会通知它的每个观察者。
RecyclerView本身设计又比较特殊，RecyclerView没有去实现Observer(这里暂且这么称呼)接口，而是内部持有一个Observer(RecyclerViewDataObserver)对象，
  进而监听Adapter的状态变化；当然Adapter也是如此，并没有去实现Observable接口，也是在内部持有一个Observable(AdapterDataObservable)对象。
我们来看Adapter的notify方法跟Observer的方法是怎么进行对应的

Adapter的notify方法	与之对应的Observer的方法
notifyItemRemoved	notifyItemRangeRemoved
notifyItemChanged	notifyItemRangeChanged
notifyItemInserted	notifyItemRangeInserted
notifyItemMoved	    notifyItemMoved

调用到Observer的方法时，Observer会调用AdapterHelper相关的方法，在AdapterHelper内部会为每个操作创建一个UpdateOp对象,
  并且添加到一个PendingUpdate数组。我们来看看相关代码(以add为例)：
```
//RecyclerViewDataObserver
        public void onItemRangeInserted(int positionStart, int itemCount) {
            assertNotInLayoutOrScroll(null);
            if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) {
                triggerUpdateProcessor();
            }
        }
```
如果onItemRangeInserted返回为true，就调用triggerUpdateProcessor方法。为什么这里需要判断是否调用triggerUpdateProcessor方法，
  其实是为了避免多次调用，比如一个操作，可能会导致多种动画执行，所以这里保证triggerUpdateProcessor方法只会被调用一次。
然后，我们来看看triggerUpdateProcessor方法：
```
void triggerUpdateProcessor() {
            if (POST_UPDATES_ON_ANIMATION && mHasFixedSize && mIsAttached) {
                ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);
            } else {
                mAdapterUpdateDuringMeasure = true;
                requestLayout();
            }
        }
final Runnable mUpdateChildViewsRunnable = new Runnable() {
        @Override
        public void run() {
            if (!mFirstLayoutComplete || isLayoutRequested()) {
                return;
            }
            if (!mIsAttached) {
                requestLayout();
                return;
            }
            if (mLayoutSuppressed) {
                mLayoutWasDefered = true;
                return;
            }
            consumePendingUpdateOperations();
        }
    };
void consumePendingUpdateOperations() {
        if (!mFirstLayoutComplete || mDataSetHasChangedAfterLayout) {
            TraceCompat.beginSection(TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG);
            dispatchLayout();
            TraceCompat.endSection();
            return;
        }
        if (!mAdapterHelper.hasPendingUpdates()) {
            return;
        }
        if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) && !mAdapterHelper
                .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE
                        | AdapterHelper.UpdateOp.MOVE)) {
            TraceCompat.beginSection(TRACE_HANDLE_ADAPTER_UPDATES_TAG);
            startInterceptRequestLayout();
            onEnterLayoutOrScroll();
            mAdapterHelper.preProcess();
            if (!mLayoutWasDefered) {
                if (hasUpdatedView()) {
                    dispatchLayout();
                } else {
                    // no need to layout, clean state
                    mAdapterHelper.consumePostponedUpdates();
                }
            }
            stopInterceptRequestLayout(true);
            onExitLayoutOrScroll();
            TraceCompat.endSection();
        } else if (mAdapterHelper.hasPendingUpdates()) {
            TraceCompat.beginSection(TRACE_ON_DATA_SET_CHANGE_LAYOUT_TAG);
            dispatchLayout();
            TraceCompat.endSection();
        }
    } 
void dispatchLayout() {
        if (mAdapter == null) {
            return;
        }
        if (mLayout == null) {
            return;
        }
        mState.mIsMeasuring = false;
        boolean needsRemeasureDueToExactSkip = mLastAutoMeasureSkippedDueToExact
                        && (mLastAutoMeasureNonExactMeasuredWidth != getWidth()
                        || mLastAutoMeasureNonExactMeasuredHeight != getHeight());
        mLastAutoMeasureNonExactMeasuredWidth = 0;
        mLastAutoMeasureNonExactMeasuredHeight = 0;
        mLastAutoMeasureSkippedDueToExact = false;

        if (mState.mLayoutStep == State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else if (mAdapterHelper.hasUpdates()
                || needsRemeasureDueToExactSkip
                || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else {
            mLayout.setExactMeasureSpecsFrom(this);
        }
        dispatchLayoutStep3();
    }               
```
其实不管是if的执行语句，还是else里面，最终还是调用了requestLayout方法，重新走一遍三大流程。
可见而知，RecyclerView的三大流程到底多么重要。这次，我们看三大流程中的dispatchLayoutStep2方法。我们知道，在Observer阶段，
  每个操作其实都创建了一个UpdateOp对象，添加到PendingUpdate数组。那么数组里面的操作都是什么时候执行的呢？
  其实就是在dispatchLayoutStep2方法阶段：
```
    private void dispatchLayoutStep2() {
        // ······
        mAdapterHelper.consumeUpdatesInOnePass();
        // ······
    }
```
真正执行PendingUpdate的操作是在AdapterHelper的consumeUpdatesInOnePass方法里面，我们来瞧瞧：
```
 void consumeUpdatesInOnePass() {
        // we still consume postponed updates (if there is) in case there was a pre-process call
        // w/o a matching consumePostponedUpdates.
        consumePostponedUpdates();
        final int count = mPendingUpdates.size();
        for (int i = 0; i < count; i++) {
            UpdateOp op = mPendingUpdates.get(i);
            switch (op.cmd) {
                case UpdateOp.ADD:
                    mCallback.onDispatchSecondPass(op);
                    mCallback.offsetPositionsForAdd(op.positionStart, op.itemCount);
                    break;
                case UpdateOp.REMOVE:
                    mCallback.onDispatchSecondPass(op);
                    mCallback.offsetPositionsForRemovingInvisible(op.positionStart, op.itemCount);
                    break;
                case UpdateOp.UPDATE:
                    mCallback.onDispatchSecondPass(op);
                    mCallback.markViewHoldersUpdated(op.positionStart, op.itemCount, op.payload);
                    break;
                case UpdateOp.MOVE:
                    mCallback.onDispatchSecondPass(op);
                    mCallback.offsetPositionsForMove(op.positionStart, op.itemCount);
                    break;
            }
            if (mOnItemProcessedCallback != null) {
                mOnItemProcessedCallback.run();
            }
        }
        recycleUpdateOpsAndClearList(mPendingUpdates);
        mExistingUpdateTypes = 0;
    }
```
虽然代码不少，但是我们发现了，最终的操作都是调用到了Callback接口里面了。而Callback做了什么呢？主要是做了两件事:
1 可能会更新一些ViewHolder的position
2 会更新一些ViewHolder的flag，比如说，remove的flag或者update的flag
这部分的内容，我们后面分析Adapter会详细的分析，本文就不做过多的介绍了。   //todo
到这里，每个ViewHolder的position都更新完毕，并且每个ViewHolder的flag也已经更新完毕。这样，到了dispatchLayoutStep3阶段，
  就知道每个ViewHolder应该做什么动画。

然后，我们来看看为什么调用Adapter的notifyDataSetChanged方法不执行动画呢？
(2). 为什么notifyDataSetChanged方法不会执行动画呢？
notifyDataSetChanged方法会回调到Observer的notifyChanged方法里面，我们看看notifyChanged方法干什么：
```          //todo requestLayout 自定义view
public void onChanged() {
    assertNotInLayoutOrScroll(null);
    mState.mStructureChanged = true;

    processDataSetCompletelyChanged(true);
    if (!mAdapterHelper.hasPendingUpdates()) {
        requestLayout();
    }
}
```
在这个方法里面，我们需要特别关注processDataSetCompletelyChanged方法。我们来看看：
```
    void processDataSetCompletelyChanged(boolean dispatchItemsChanged) {
        mDispatchItemsChangedEvent |= dispatchItemsChanged;
        mDataSetHasChangedAfterLayout = true;
        markKnownViewsInvalid();
    }

void markKnownViewsInvalid() {
        final int cachedCount = mCachedViews.size();
        for (int i = 0; i < cachedCount; i++) {
            final ViewHolder holder = mCachedViews.get(i);
            if (holder != null) {
                holder.addFlags(ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID);
                holder.addChangePayload(null);
            }
        }

        if (mAdapter == null || !mAdapter.hasStableIds()) {
            // we cannot re-use cached views in this case. Recycle them all
            recycleAndClearCachedViews();
        }
    }    
```

在processDataSetCompletelyChanged方法里面，调用了markKnownViewsInvalid方法所有的ViewHolder标记为了FLAG_INVALID。
 这个操作直接导致了，我们在预布局阶段不能正确获得每个ItemView的位置信息和OldViewHolder,进而导致在后布局阶段不能执行动画。
  这就是notifyDataSetChanged方法为什么不执行动画的原因。
```
private void dispatchLayoutStep1() {   //预布局中标记为Invalid的不收集对应信息
...
if (mState.mRunSimpleAnimations) {
            // Step 0: Find out where all non-removed items are, pre-layout
            int count = mChildHelper.getChildCount();
            for (int i = 0; i < count; ++i) {
                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) {
                    continue;
                }
...                
```

3. 总结
   RecyclerView的动画机制还是比较简单的，这里我们对它做一个简单的总结。
1 RecyclerView执行动画的机制在于，在预布局阶段将每个ItemView的位置信息和ViewHolder保存起来，在后布局阶段，
   根据每个ItemView的ViewHolder flag状态来判断执行什么动画，根据位置信息来判断怎么做动画。
2 Adapter的notify方法之所以能够执行动画，是因为他们在三大流程中给每个ViewHolder打了响应的flag,包括remove的flag或者update的flag等。
   而在后布局中，正是根据flag来执行不同的动画的。
3 notifyDataSetChanged方法之所以不支持动画，那是因为notifyDataSetChanged方法会使每个ViewHolder失效(打了FLAG_INVALID标记)，
   所以导致在预布局阶段，不能正确的获得每个ItemView的位置信息和ViewHolder，进而导致动画不能执行。




ItemAnimator相关的
ItemAnimator作为RecyclerView的主要组成部分之一，其重要性自然不可言喻。因为ItemAnimator的存在，所以出现了很多精彩纷呈的动画，
这使得RecyclerView更加惹人喜爱。因此，学习ItemAnimator的源码是势在必行的，因为我们了解原理之后，就可以自定义动画了，不再受人束缚。
本文打算才如下几个部分来分析ItemAnimator的源码：
1 ItemAnimator类相关方法的分析和总结。
2 SimpleItemAnimator相关代码的分析。
3 DefaultItemAnimator相关代码的分析。
4 自定义一个ItemAnimator。

1. 概述
   首先我们来对ItemAnimator的整个结构做一个简单的概述，方便大家理解。
   通常来说，自定义一个ItemAnimator的过程是：ItemAnimator ->SimpleItemAnimator -> 自定义ItemAnimator。
   包括官方提供的DefaultItemAnimator也是这样来定义的，那这样来定义有好处的呢？这样定义，结构层次比较清晰，我们自定义ItemAnimator比较方便，
   只需要关注动画怎么实现就行。我们来看看这三层分别干了什么：

结构层次	            作用
ItemAnimator	    定义ItemAnimator的模板，自定义这里包括4个抽象方法，也是非常重要的抽象方法，分别是：
                       animateDisappearance、animateAppearance、animatePersistence和animateChange。
SimpleItemAnimator	实现了四个抽象方法，根据调用4个抽象方法的时机不同，所以会做不同的动画，所以又对外提供了4个抽象方法，
                     分别是：animateRemove、animateAdd，animateMove和animateChange，分别对应删除、添加、移动和改变的动画。
自定义ItemAnimator	主要实现4种操作的动画，也包括结束动画相关实现

而我们在自定义ItemAnimator时，只需要考虑第三层就OK，上面两层的逻辑谷歌爸爸已经帮我们实现了。自定义过ItemAnimator的同学应该都知道，
  尽管只关注第三层，但是实现还是那么麻烦，介于这个问题，我会提出一个非常简单的自定义itemAnimator的方案

2. ItemAnimator
   我们从上往下，看看每一层都为我们做了哪些事情，首先我们来了解一下ItemAnimator。ItemAnimator总的来说比较简单，
   我们来看看ItemAnimator几个方法：
   方法名	            作用
   animateDisappearance	抽象方法，供第二层实现。此方法的调用时机是ItemView从当前的可见区域消失，
                       其中包括：1.ItemView执行了remove操作；2. ItemView执行move操作移动到不可见区域。在此方法里面，根据不同的情况，
                       执行move动画或者执行remove动画
   animateAppearance	抽象方法，供第二层实现。此方法的调用时机是ItemView出现在可见区域，其中包括：
                          1. ItemView执行了add操作；2. ItemView执行move操作从不可见区域移动到可见区域。在此方法里面，根据不同的情况，
                           执行add动画或者执行move动画。
   animatePersistence	抽象方法，供第二层实现。此方法的调用时机是ItemView未进行任何操作。在此方法里面，根据不同的情况，
                           会执行remove动画(比如说当前ItemView上面有一个ItemView执行了reomve操作)或者无任何动画。
   animateChange	抽象方法，供第二层实现。此方法的调用时机是ItemView进行了change操作。在方法里面，会执行change动画。

在ItemAnimator中，上面4个方法非常的重要，RecyclerView就是通过这四个方法来给每个ItemView添加不同的动画。在这一层，我们需要掌握的就是，
  记住这4个方法的调用时机，这样我们在看SimpleItemAnimator代码时，才不会不知所措。

3. SimpleItemAnimator
   就像在上面概述所说的一样，SimpleItemAnimator处于第二层，负责实现ItemAnimator的4个抽象方法，然后又提供了四种操作需要分别调用的抽象方法，
     这样做就更加细化了动画执行的情况，简化了自定义ItemAnimator的过程。
   在正式看SimpleItemAnimator的源码之前，我们先来看看SimpleItemAnimator几个方法的介绍。

方法名	          参数	     说明
animateRemove	ViewHolder	当前的ItemView执行了remove操作需要执行remove动画时，会回调此方法。
animateAdd   	ViewHolder	当前的ItemView执行了add操作需要执行add动画时，会回调此方法。
animateMove	    ViewHolder	当前的ItemView执行了move操作，或者它之前有ItemView执行了remove操作或者add操作，会回调此方法。
animateChange	ViewHolder 
           oldHolder,ViewHolder newHolder,
          int fromLeft, int fromTop, int toLeft, int toTop	当前的ItemView执行了change操作，会调用此方法。

我们看到到了SimpleItemAnimator这一层，每个ItemView应该做什么动画，现在已经一清二楚了，不再像第一层里面那样，一个方法里面可能涉及到多种情况，
   每种情况可能执行不同的动画。  //将动画细化为具体的操作
现在我们分别来看看SimpleItemAnimator对ItemAnimator的4个抽象方法的实现，看看他是怎么来判断一个ItemView执行何种动画的。
首先，我们来看一下animateDisappearance方法：
```
public boolean animateDisappearance(@NonNull RecyclerView.ViewHolder viewHolder,
            @NonNull ItemHolderInfo preLayoutInfo, @Nullable ItemHolderInfo postLayoutInfo) {
        int oldLeft = preLayoutInfo.left;
        int oldTop = preLayoutInfo.top;
        View disappearingItemView = viewHolder.itemView;
        int newLeft = postLayoutInfo == null ? disappearingItemView.getLeft() : postLayoutInfo.left;
        int newTop = postLayoutInfo == null ? disappearingItemView.getTop() : postLayoutInfo.top;
        if (!viewHolder.isRemoved() && (oldLeft != newLeft || oldTop != newTop)) {
            disappearingItemView.layout(newLeft, newTop,
                    newLeft + disappearingItemView.getWidth(),
                    newTop + disappearingItemView.getHeight());
            return animateMove(viewHolder, oldLeft, oldTop, newLeft, newTop);
        } else {
            return animateRemove(viewHolder);
        }
    }
```
animateDisappearance方法表达的意思非常简单，首先判断当前ItemView是否需要执行的是move动画，如果是，那么就调用animateMove方法；
  如果不是的话，那么就调用animateRemove方法用来执行remove动画。
在这个方法里面，remove操作我们理解，但是move操作是什么意思呢？首先我们得搞清楚animateDisappearance方法的调用时机，
   animateDisappearance方法表示在ItemView从可见状态变为不可见状态，这里包括：remove操作和ItemView从可见区域移动到不可见区域。
   所以在animateDisappearance方法里面，执行move动画并不意外。
然后，我们来看一下animateAppearance方法：
```
public boolean animateAppearance(@NonNull RecyclerView.ViewHolder viewHolder,
            @Nullable ItemHolderInfo preLayoutInfo, @NonNull ItemHolderInfo postLayoutInfo) {
        if (preLayoutInfo != null && (preLayoutInfo.left != postLayoutInfo.left
                || preLayoutInfo.top != postLayoutInfo.top)) {
            // slide items in if before/after locations differ
            return animateMove(viewHolder, preLayoutInfo.left, preLayoutInfo.top,
                    postLayoutInfo.left, postLayoutInfo.top);
        } else {
            return animateAdd(viewHolder);
        }
    }
```
animateAppearance方法表示在ItemView从不可见状态变为可见状态，所以这里包括add操作和move操作。
   move操作表示的意思跟animateDisappearance方法的差不多。
然后，我们再来看看animatePersistence方法:
```
   public boolean animatePersistence(@NonNull RecyclerView.ViewHolder viewHolder,
            @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) {
        if (preInfo.left != postInfo.left || preInfo.top != postInfo.top) {
            return animateMove(viewHolder,
                    preInfo.left, preInfo.top, postInfo.left, postInfo.top);
        }
        dispatchMoveFinished(viewHolder);
        return false;
    }
```
animatePersistence方法比其他方法都简单，这里只进行了move动画。当然如果不执行任何动画，这里会返回false，
并且会调用dispatchMoveFinished方法，这是基本要求，当每个动画执行完毕之后，都是调用相关方法来通知动画执行结束了。
最后，我们再来看看animateChange方法：
```
 public boolean animateChange(@NonNull RecyclerView.ViewHolder oldHolder, @NonNull RecyclerView.ViewHolder newHolder,
            @NonNull ItemHolderInfo preInfo, @NonNull ItemHolderInfo postInfo) {
        final int fromLeft = preInfo.left;
        final int fromTop = preInfo.top;
        final int toLeft, toTop;
        if (newHolder.shouldIgnore()) {
            toLeft = preInfo.left;
            toTop = preInfo.top;
        } else {
            toLeft = postInfo.left;
            toTop = postInfo.top;
        }
        return animateChange(oldHolder, newHolder, fromLeft, fromTop, toLeft, toTop);
    }
```
animateChange方法更加的简单，最后始终调用了animateChange抽象方法。


4. DefaultItemAnimator
   我们在看DefaultItemAnimator的源码之前，先来看看它有哪些成员变量：
```
    private static TimeInterpolator sDefaultInterpolator;

    private ArrayList<ViewHolder> mPendingRemovals = new ArrayList<>();
    private ArrayList<ViewHolder> mPendingAdditions = new ArrayList<>();
    private ArrayList<MoveInfo> mPendingMoves = new ArrayList<>();
    private ArrayList<ChangeInfo> mPendingChanges = new ArrayList<>();

    ArrayList<ArrayList<ViewHolder>> mAdditionsList = new ArrayList<>();
    ArrayList<ArrayList<MoveInfo>> mMovesList = new ArrayList<>();
    ArrayList<ArrayList<ChangeInfo>> mChangesList = new ArrayList<>();

    ArrayList<ViewHolder> mAddAnimations = new ArrayList<>();
    ArrayList<ViewHolder> mMoveAnimations = new ArrayList<>();
    ArrayList<ViewHolder> mRemoveAnimations = new ArrayList<>();
    ArrayList<ViewHolder> mChangeAnimations = new ArrayList<>();
```   
在DefaultItemAnimator的内部，成员变量主要分为4个部分。
这其中，sDefaultInterpolator就是给ItemView设置的一个动画插值器对象，在DefaultItemAnimator内部，这个插值器是AccelerateDecelerateInterpolator插值器；
然后第二部分mPendingxxx数组，这部分就是用来存储每个ItemView需要做动画的相关信息，例如，move动画就需要移动的起始位置和终点位置，
  这部分的数组才是做动画的真正做动画需要的；
第三部分和第四部分是mXXXList和mXXXAnimations，通常来说，都是用于结束动画的，本文后面会简单的分析他们。
简单的了解这四部分的成员变量之后，现在我们重点看一下四个抽象方法的实现

(1). animateRemove
```
    public boolean animateRemove(final ViewHolder holder) {
        resetAnimation(holder);
        mPendingRemovals.add(holder);
        return true;
    }
```
animateRemove方法的实现非常简单，就是往mPendingRemovals数组里面添加一个元素。

(2). animateAdd
```
   public boolean animateAdd(final RecyclerView.ViewHolder holder) {
        resetAnimation(holder);
        holder.itemView.setAlpha(0);
        mPendingAdditions.add(holder);
        return true;
    }
```
animateAdd方法的实现也是非常简单。这里我们看到有一个操作就是holder.itemView.setAlpha(0)，我们都知道，
   在DefaultItemAnimator中，add动画是一个渐现的过程，这里先将ItemView的alpha值设置0就容易理解了

(3). animateMove
```
public boolean animateMove(final RecyclerView.ViewHolder holder, int fromX, int fromY,
            int toX, int toY) {
        final View view = holder.itemView;
        fromX += (int) holder.itemView.getTranslationX();
        fromY += (int) holder.itemView.getTranslationY();
        resetAnimation(holder);
        int deltaX = toX - fromX;
        int deltaY = toY - fromY;
        if (deltaX == 0 && deltaY == 0) {
            dispatchMoveFinished(holder);
            return false;
        }
        if (deltaX != 0) {
            view.setTranslationX(-deltaX);
        }
        if (deltaY != 0) {
            view.setTranslationY(-deltaY);
        }
        mPendingMoves.add(new MoveInfo(holder, fromX, fromY, toX, toY));
        return true;
    }
```
相对来说，animateMove的实现比其他操作都要复杂一些，但是再怎么复杂，其实就做了两件事：
1 根据情况，来设置View的translationX或者translationY。
2 向mPendingMoves数组里面添加一个MoveInfo,用于move动画使用。

(4). animateChange
```
 public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder,
            int fromX, int fromY, int toX, int toY) {
        if (oldHolder == newHolder) {
            return animateMove(oldHolder, fromX, fromY, toX, toY);
        }
        final float prevTranslationX = oldHolder.itemView.getTranslationX();
        final float prevTranslationY = oldHolder.itemView.getTranslationY();
        final float prevAlpha = oldHolder.itemView.getAlpha();
        resetAnimation(oldHolder);
        int deltaX = (int) (toX - fromX - prevTranslationX);
        int deltaY = (int) (toY - fromY - prevTranslationY);
        // recover prev translation state after ending animation
        oldHolder.itemView.setTranslationX(prevTranslationX);
        oldHolder.itemView.setTranslationY(prevTranslationY);
        oldHolder.itemView.setAlpha(prevAlpha);
        if (newHolder != null) {
            // carry over translation values
            resetAnimation(newHolder);
            newHolder.itemView.setTranslationX(-deltaX);
            newHolder.itemView.setTranslationY(-deltaY);
            newHolder.itemView.setAlpha(0);
        }
        mPendingChanges.add(new ChangeInfo(oldHolder, newHolder, fromX, fromY, toX, toY));
        return true;
    }
```
而change操作比较特殊，哪里特殊呢？主要有两点：
1 它涉及到从旧状态变成新状态，所以需要考虑两个ItemView的存在。
2 在做change操作时，可能会做move操作。所以在这里还设置了ItemView的translation。
这里只是简单的介绍了ItemView可能同时进行change操作和move操作，待会在将动画实现时，我们来看一下DefaultItemAnimator
  是怎么实现两个动画同时进行的

(5). runPendingAnimations
我们往数组里面添加了很多需要做动画的元素，但是什么时候开始执行这些动画呢？
 前面已经分析了RecyclerView是怎么开始动画的。其实就是回调了ItemAnimator的一个方法--runPendingAnimations方法，
  之前我们添加的所有动画都在方法里面执行。我们在看runPendingAnimations方法之前，我们有几个问题，我们带着问题去看思路会更加的清晰，
  一共两个问题:
1 DefaultItemAnimator是怎么实现每种操作的动画呢？
2 我们知道，在RecyclerView中，某些操作的动画是时序，比如说，必须在remove动画执行完毕之后，才会执行move动画，这个又是怎么实现呢？
```
//DefaultItemAnimator.java
 public void runPendingAnimations() {
        boolean removalsPending = !mPendingRemovals.isEmpty();
        boolean movesPending = !mPendingMoves.isEmpty();
        boolean changesPending = !mPendingChanges.isEmpty();
        boolean additionsPending = !mPendingAdditions.isEmpty();
        if (!removalsPending && !movesPending && !additionsPending && !changesPending) {
            // nothing to animate
            return;
        }
        //1 remove 动画
        for (RecyclerView.ViewHolder holder : mPendingRemovals) {
            animateRemoveImpl(holder);
        }
        mPendingRemovals.clear();
        //2 move动画
        if (movesPending) {
            final ArrayList<MoveInfo> moves = new ArrayList<>();
            moves.addAll(mPendingMoves);
            mMovesList.add(moves);
            mPendingMoves.clear();
            Runnable mover = new Runnable() {
                @Override
                public void run() {
                    for (MoveInfo moveInfo : moves) {
                        animateMoveImpl(moveInfo.holder, moveInfo.fromX, moveInfo.fromY,
                                moveInfo.toX, moveInfo.toY);
                    }
                    moves.clear();
                    mMovesList.remove(moves);
                }
            };
            if (removalsPending) {
                View view = moves.get(0).holder.itemView;
                ViewCompat.postOnAnimationDelayed(view, mover, getRemoveDuration());
            } else {
                mover.run();
            }
        }
        // 3 change动画 与move并行
        if (changesPending) {
            final ArrayList<ChangeInfo> changes = new ArrayList<>();
            changes.addAll(mPendingChanges);
            mChangesList.add(changes);
            mPendingChanges.clear();
            Runnable changer = new Runnable() {
                @Override
                public void run() {
                    for (ChangeInfo change : changes) {
                        animateChangeImpl(change);
                    }
                    changes.clear();
                    mChangesList.remove(changes);
                }
            };
            if (removalsPending) {
                RecyclerView.ViewHolder holder = changes.get(0).oldHolder;
                ViewCompat.postOnAnimationDelayed(holder.itemView, changer, getRemoveDuration());
            } else {
                changer.run();
            }
        }
        // 4 add动画
        if (additionsPending) {
            final ArrayList<RecyclerView.ViewHolder> additions = new ArrayList<>();
            additions.addAll(mPendingAdditions);
            mAdditionsList.add(additions);
            mPendingAdditions.clear();
            Runnable adder = new Runnable() {
                @Override
                public void run() {
                    for (RecyclerView.ViewHolder holder : additions) {
                        animateAddImpl(holder);
                    }
                    additions.clear();
                    mAdditionsList.remove(additions);
                }
            };
            if (removalsPending || movesPending || changesPending) {
                long removeDuration = removalsPending ? getRemoveDuration() : 0;
                long moveDuration = movesPending ? getMoveDuration() : 0;
                long changeDuration = changesPending ? getChangeDuration() : 0;
                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);
                View view = additions.get(0).itemView;
                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay);
            } else {
                adder.run();
            }
        }
    }
```

通过阅读runPendingAnimations方法的源码，我们可以将它的源码分为4个部分，分别如下：
1 remove动画的执行 
2 move动画的执行
3 change动画的执行
4 add动画的执行
我们分别来看看这四部分的代码。

A. remove动画的执行   
通过上面的代码，我们知道，remove动画的实现关键在于animateRemoveImpl方法，我们来看看animateRemoveImpl方法的实现：
```
private void animateRemoveImpl(final RecyclerView.ViewHolder holder) {
        final View view = holder.itemView;
        final ViewPropertyAnimator animation = view.animate();
        mRemoveAnimations.add(holder);
        animation.setDuration(getRemoveDuration()).alpha(0).setListener(
                new AnimatorListenerAdapter() {
                    @Override
                    public void onAnimationStart(Animator animator) {
                        dispatchRemoveStarting(holder);
                    }

                    @Override
                    public void onAnimationEnd(Animator animator) {
                        animation.setListener(null);
                        view.setAlpha(1);
                        dispatchRemoveFinished(holder);
                        mRemoveAnimations.remove(holder);
                        dispatchFinishedWhenDone();
                    }
                }).start();
    }
```
在这里，我们知道，ItemView的remove动画是通过ViewPropertyAnimator来实现的。在这里我们需要注意几点：
1 在动画开始之前，往mRemoveAnimations数组里面添加了一个元素，主要是用于结束动画的操作。当我们在结束动画时，
  发现mRemoveAnimations数组里面还有元素，表示还有remove动画没有执行完毕，所以结束它。  //结束动画在endAnimations()
2 在onAnimationEnd方法里面，我们分别调用了dispatchRemoveFinished方法和dispatchFinishedWhenDone。这两步操作是必须的，
  而且注意他们的时序。

B. move动画
这部分的代码相对来说要复杂一点点，我们来简单的分析一下。上面的代码，我们需要注意如如下几点:
将move动画相关的动画元素原封不动的添加到mMovesList数组里面。这样做的目的是，因为move动画的开始有延迟，得等待remove动画执行完毕之后才执行。
  所以，存在我们在结束动画时，move动画还没有开始执行的情况，所以得先添加进去，以便结束move动画。
从这里我们就可以知道，DefaultItemAnimator是怎么解决动画的时序问题。这里通过ViewCompat的postOnAnimationDelayed来做一个延迟执行，
  保证rmove动画执行完毕才执行move动画。

然后，我们在来看看animateMoveImpl方法是怎么实现move动画的：
```
void animateMoveImpl(final RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {
        final View view = holder.itemView;
        final int deltaX = toX - fromX;
        final int deltaY = toY - fromY;
        if (deltaX != 0) {
            view.animate().translationX(0);
        }
        if (deltaY != 0) {
            view.animate().translationY(0);
        }
        final ViewPropertyAnimator animation = view.animate();
        mMoveAnimations.add(holder);
        animation.setDuration(getMoveDuration()).setListener(new AnimatorListenerAdapter() {
            public void onAnimationStart(Animator animator) {
                dispatchMoveStarting(holder);
            }

            public void onAnimationCancel(Animator animator) {
                if (deltaX != 0) {
                    view.setTranslationX(0);
                }
                if (deltaY != 0) {
                    view.setTranslationY(0);
                }
            }

            public void onAnimationEnd(Animator animator) {
                animation.setListener(null);
                dispatchMoveFinished(holder);
                mMoveAnimations.remove(holder);
                dispatchFinishedWhenDone();
            }
        }).start();
    }
```
animateMoveImpl方法实现move动画其实跟remove的实现差不多，都是通过ViewPropertyAnimator来实现的

C. change动画
上面的代码跟move动画那部分的实现都差不多，这里就不再分析了，我们这里重点是看animateChangeImpl方法：
```
void animateChangeImpl(final ChangeInfo changeInfo) {
        final RecyclerView.ViewHolder holder = changeInfo.oldHolder;
        final View view = holder == null ? null : holder.itemView;
        final RecyclerView.ViewHolder newHolder = changeInfo.newHolder;
        final View newView = newHolder != null ? newHolder.itemView : null;
        if (view != null) {
            final ViewPropertyAnimator oldViewAnim = view.animate().setDuration(
                    getChangeDuration());
            mChangeAnimations.add(changeInfo.oldHolder);
            oldViewAnim.translationX(changeInfo.toX - changeInfo.fromX);
            oldViewAnim.translationY(changeInfo.toY - changeInfo.fromY);
            oldViewAnim.alpha(0).setListener(new AnimatorListenerAdapter() {
                @Override
                public void onAnimationStart(Animator animator) {
                    dispatchChangeStarting(changeInfo.oldHolder, true);
                }

                @Override
                public void onAnimationEnd(Animator animator) {
                    oldViewAnim.setListener(null);
                    view.setAlpha(1);
                    view.setTranslationX(0);
                    view.setTranslationY(0);
                    dispatchChangeFinished(changeInfo.oldHolder, true);
                    mChangeAnimations.remove(changeInfo.oldHolder);
                    dispatchFinishedWhenDone();
                }
            }).start();
        }
        if (newView != null) {
            final ViewPropertyAnimator newViewAnimation = newView.animate();
            mChangeAnimations.add(changeInfo.newHolder);
            newViewAnimation.translationX(0).translationY(0).setDuration(getChangeDuration())
                    .alpha(1).setListener(new AnimatorListenerAdapter() {
                        @Override
                        public void onAnimationStart(Animator animator) {
                            dispatchChangeStarting(changeInfo.newHolder, false);
                        }
                        @Override
                        public void onAnimationEnd(Animator animator) {
                            newViewAnimation.setListener(null);
                            newView.setAlpha(1);
                            newView.setTranslationX(0);
                            newView.setTranslationY(0);
                            dispatchChangeFinished(changeInfo.newHolder, false);
                            mChangeAnimations.remove(changeInfo.newHolder);
                            dispatchFinishedWhenDone();
                        }
                    }).start();
        }
    }
```
change跟其他比较起来，实现起来就复杂的多。我们来简单的分析一下：
1 在animateChangeImpl方法里面，主要是有两个动画在执行，一个是旧的ItemView渐隐动画，一个是新的ItemView渐现动画。
2 在change动画里面，同时包含了两部分属性的动画，一个是位置的渐变，一个是透明度的渐变。从这里，我们就可以看到，
  一个在做change动画的ItemView也有可能做move动画。

D. add动画
```
void animateAddImpl(final RecyclerView.ViewHolder holder) {
        final View view = holder.itemView;
        final ViewPropertyAnimator animation = view.animate();
        mAddAnimations.add(holder);
        animation.alpha(1).setDuration(getAddDuration())
                .setListener(new AnimatorListenerAdapter() {
                    public void onAnimationStart(Animator animator) {
                        dispatchAddStarting(holder);
                    }
                    public void onAnimationCancel(Animator animator) {
                        view.setAlpha(1);
                    }
                    public void onAnimationEnd(Animator animator) {
                        animation.setListener(null);
                        dispatchAddFinished(holder);
                        mAddAnimations.remove(holder);
                        dispatchFinishedWhenDone();
                    }
                }).start();
    }
```
通过ViewPropertyAnimator实现的渐显动画


5. 自定义ItemAnimator
   大家想要自定以一个ItemAnimator，第一个想法就是先去网上搜索一下自定以ItemAnimator的基本步骤。我相信大家搜索到的都是一开始就叫我们实现很多很多的方法，
   又不知道这些的作用，有些可能还简单介绍了一下每个方法的作用，但是根本不知道这个方法的具体实现。为什么需要这么来实现动画呢？
   这些都是网上大多数文章没有介绍清楚的。
   通过上面的源码的学习，我们了解了DefaultItemAnimator的实现原理。所以，我们自定义一个ItemAnimator，可以参考DefaultItemAnimator的实现。
   从而，我们自定义一个ItemAnimator,需要解决如下几个问题：
   1 需要考虑动画执行的时序。
   2 需要考虑结束动画。
   3 实现每种动画的实现逻辑。

从上面的问题中，我们发现问题1和问题2,DefaultItemAnimator已经帮我们实现了，我们只需要解决问题3就行了。所以，我的解决方案就是：
将DefaultItemAnimator的拷贝出来，我们只需要改写animateRemoveImpl、animateAddImpl、animateMoveImpl和animateChangeImpl这四个方法就行了。
通常来说，change动画和move动画，我们都不会改写，所以重点在于add动画和remove动画。
//继承DefaultItemAnimator，重写animateRemoveImpl、animateAddImpl、animateMoveImpl和animateChangeImpl


6. 总结
 关于ItemAnimator的源码分析到此就已经结束了，我在这里做一个简单的总结。

理解ItemAnimator的原理之前，我们最好先了解它的三层模型，分别是ItemAnimator、SimpleItemAnimator和DefaultItemAnimator，
   我们需要搞清楚每一层到底为我们做了哪些事情。
自定义ItemAnimator我们只需要拷贝DefaultItemAnimator的代码，然后根据自己的要求分别改写animateRemoveImpl、animateAddImpl、
   animateMoveImpl和animateChangeImpl这四个方法就行了


