https://juejin.cn/post/6844903751912783880#heading-2

缓存的加载 是从engine.load()开始的
Engine.java
```
 public <R> LoadStatus load(
      GlideContext glideContext,
      Object model,
      Key signature,
      int width,
      int height,
      Class<?> resourceClass,
      Class<R> transcodeClass,
      Priority priority,
      DiskCacheStrategy diskCacheStrategy,
      Map<Class<?>, Transformation<?>> transformations,
      boolean isTransformationRequired,
      boolean isScaleOnlyOrNoTransform,
      Options options,
      boolean isMemoryCacheable,
      boolean useUnlimitedSourceExecutorPool,
      boolean useAnimationPool,
      boolean onlyRetrieveFromCache,
      ResourceCallback cb,
      Executor callbackExecutor) {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;
    //根据宽高，变化，option等生成key
    EngineKey key =
        keyFactory.buildKey(
            model,
            signature,
            width,
            height,
            transformations,
            resourceClass,
            transcodeClass,
            options);

    EngineResource<?> memoryResource;
    synchronized (this) {
      //从内存获取
      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);

      if (memoryResource == null) {
        //查找已存在的或者开始新的job
        return waitForExistingOrStartNewJob(
            glideContext,
            model,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            options,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache,
            cb,
            callbackExecutor,
            key,
            startTime);
      }
    }

    //回调
    cb.onResourceReady(
        memoryResource, DataSource.MEMORY_CACHE, /* isLoadedFromAlternateCacheKey= */ false);
    return null;
  }
  
  private EngineResource<?> loadFromMemory(
      EngineKey key, boolean isMemoryCacheable, long startTime) {
    if (!isMemoryCacheable) {
      return null;
    }
    //从当前正在使用的Resources里面去
    EngineResource<?> active = loadFromActiveResources(key);
    if (active != null) {
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return active;
    }
    //从内存缓存中获取
    EngineResource<?> cached = loadFromCache(key);
    ...

    return null;
  }

  private <R> LoadStatus waitForExistingOrStartNewJob(
      GlideContext glideContext,
      Object model,
      Key signature,
      int width,
      int height,
      Class<?> resourceClass,
      Class<R> transcodeClass,
      Priority priority,
      DiskCacheStrategy diskCacheStrategy,
      Map<Class<?>, Transformation<?>> transformations,
      boolean isTransformationRequired,
      boolean isScaleOnlyOrNoTransform,
      Options options,
      boolean isMemoryCacheable,
      boolean useUnlimitedSourceExecutorPool,
      boolean useAnimationPool,
      boolean onlyRetrieveFromCache,
      ResourceCallback cb,
      Executor callbackExecutor,
      EngineKey key,
      long startTime) {

    //从已存在的任务中对应的EngineJob获取job
    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
      current.addCallback(cb, callbackExecutor);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Added to existing load", startTime, key);
      }
      return new LoadStatus(cb, current);
    }
    //创建新的EngineJob
    EngineJob<R> engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);
    //创建新的DecodeJob
    DecodeJob<R> decodeJob =
        decodeJobFactory.build(
            glideContext,
            model,
            key,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            onlyRetrieveFromCache,
            options,
            engineJob);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    engineJob.start(decodeJob);

    ...
    return new LoadStatus(cb, engineJob);
  }
```

内存缓存第一阶段
主要是loadFromActiveResources流程
```
  private EngineResource<?> loadFromActiveResources(Key key) {
    //从ActiveResources的弱引用map查找 如果active为null,从map中移除 
    EngineResource<?> active = activeResources.get(key);
    if (active != null) {
      active.acquire();
    }
    return active;
  }
```
ActiveResource的要从activeResources中获取，activeResources在Engine构造方法中创建
```
  Engine(
      MemoryCache cache,
      DiskCache.Factory diskCacheFactory,
      GlideExecutor diskCacheExecutor,
      GlideExecutor sourceExecutor,
      GlideExecutor sourceUnlimitedExecutor,
      GlideExecutor animationExecutor,
      Jobs jobs,
      EngineKeyFactory keyFactory,
      ActiveResources activeResources,
      EngineJobFactory engineJobFactory,
      DecodeJobFactory decodeJobFactory,
      ResourceRecycler resourceRecycler,
      boolean isActiveResourceRetentionAllowed) {
       ...
        if (activeResources == null) {
          activeResources = new ActiveResources(isActiveResourceRetentionAllowed);
        }
        this.activeResources = activeResources;
        activeResources.setListener(this);
        ... 
      }
```

我们分析ActiveResource类的简单实现
```
final class ActiveResources {
  private final boolean isActiveResourceRetentionAllowed;
  private final Executor monitorClearedResourcesExecutor;
  //ResourceWeakReference是使用WeakReference对EngineResource进行包装
  final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
  //弱引用队列
  private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();

  private ResourceListener listener;

  private volatile boolean isShutdown;
   private volatile DequeuedResourceCallback cb;

  ActiveResources(boolean isActiveResourceRetentionAllowed) {
    this(
        isActiveResourceRetentionAllowed,
        //创建单线程线程池
        java.util.concurrent.Executors.newSingleThreadExecutor(
            new ThreadFactory() {
              @Override
              public Thread newThread(@NonNull final Runnable r) {
                return new Thread(
                    new Runnable() {
                      @Override
                      public void run() {
                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                        r.run();
                      }
                    },
                    "glide-active-resources");
              }
            }));
  }

  ActiveResources(
      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {
    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
    this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;

    monitorClearedResourcesExecutor.execute(
        new Runnable() {
          @Override
          public void run() {
            //不断执行清理工作
            cleanReferenceQueue();
          }
        });
  }

  void setListener(ResourceListener listener) {
    synchronized (listener) {
      synchronized (this) {
        this.listener = listener;
      }
    }
  }

  //activate方法，相当于put
  synchronized void activate(Key key, EngineResource<?> resource) {
    ResourceWeakReference toPut =
        new ResourceWeakReference(
            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
   
    
    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
    //移除的弱引用对象需要清除强引用
    if (removed != null) {
      //removed是之前key对应的value，不为null，清除之前的
      removed.reset();
    }
  }

  synchronized void deactivate(Key key) {
    ResourceWeakReference removed = activeEngineResources.remove(key);
    if (removed != null) {
      removed.reset();
    }
  }

  //获取激活的资源
  synchronized EngineResource<?> get(Key key) {
    ResourceWeakReference activeRef = activeEngineResources.get(key);
    if (activeRef == null) {
      return null;
    }

    EngineResource<?> active = activeRef.get();
    if (active == null) {
      cleanupActiveReference(activeRef);
    }
    return active;
  }

  //清除当前被GC的ref对象
  @Synthetic
  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
    synchronized (this) {
      //从map中移除掉
      activeEngineResources.remove(ref.key);
      //如果EngineResources不能缓存或者里面的resource为null
      if (!ref.isCacheable || ref.resource == null) {
        return;
      }
    }
    //创建新的对象EngineResource，复用ref.resource
    EngineResource<?> newResource =
        new EngineResource<>(
            ref.resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, ref.key, listener);
    //回调onResourceReleased   移除了EngineResource，现在需要处理EngineResource.resource
    listener.onResourceReleased(ref.key, newResource);
  }

  //清除回收对象
  @Synthetic
  void cleanReferenceQueue() {
    while (!isShutdown) {
      try {
        //拿到待清除的引用ResourceWeakReference
        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
        cleanupActiveReference(ref);

        // This section for testing only.
        DequeuedResourceCallback current = cb;
        if (current != null) {
          current.onResourceDequeued();
        }
        // End for testing only.
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }

  void setDequeuedResourceCallback(DequeuedResourceCallback cb) {
    this.cb = cb;
  }

  interface DequeuedResourceCallback {
    void onResourceDequeued();
  }

  //shutdown中断线程池线程，清除队列
  void shutdown() {
    isShutdown = true;
    if (monitorClearedResourcesExecutor instanceof ExecutorService) {
      ExecutorService service = (ExecutorService) monitorClearedResourcesExecutor;
      Executors.shutdownAndAwaitTermination(service);
    }
  }

  //使用WeakReference对EngineResource进行包装
  static final class ResourceWeakReference extends WeakReference<EngineResource<?>> {
    final Key key;
    final boolean isCacheable;
    //强引用，真正的资源
    @Synthetic
    Resource<?> resource;
    @Synthetic
    ResourceWeakReference(
        @NonNull Key key,
        @NonNull EngineResource<?> referent,
        @NonNull ReferenceQueue<? super EngineResource<?>> queue,
        boolean isActiveResourceRetentionAllowed) {
      super(referent, queue);
      this.key = Preconditions.checkNotNull(key);
      this.resource =
          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed
              ? Preconditions.checkNotNull(referent.getResource())
              : null;
      isCacheable = referent.isMemoryCacheable();
    }
    //清除资源
    void reset() {
      resource = null;
      clear();
    }
  }
}
```
ActiveResource缓存原理
ActiveResources采用HashMap+WeakRefence方式保存EngineResource对象，没有对集合size做限制，在使用WeakReference的时候，
创建了一个ReferenceQueue，来记录被GC回收的EngineResource对象，而且在创建ReferenceQueue时生成了一个线程池后台线程"glide-active-resources"，
不断地执行cleanReferenceQueue()方法，一旦ReferenceQueue取出不为空，便取出ref对象，执行cleanupActiveReference()方法
释放缓存并重用到MemoryCache


有必要看一下EngineResource类结构：
EngineResource对Resource进行了包装，并使用引用计数法确定Resource的释放时机
```
class EngineResource<Z> implements Resource<Z> {
  private final boolean isMemoryCacheable;
  private final boolean isRecyclable;
  private final Resource<Z> resource;
  private final ResourceListener listener;
  private final Key key;

  private int acquired;
  private boolean isRecycled;

  //监听资源释放，没有被引用了
  interface ResourceListener {
    void onResourceReleased(Key key, EngineResource<?> resource);
  }

  EngineResource(
      Resource<Z> toWrap,
      boolean isMemoryCacheable,
      boolean isRecyclable,
      Key key,
      ResourceListener listener) {
    resource = Preconditions.checkNotNull(toWrap);
    this.isMemoryCacheable = isMemoryCacheable;
    this.isRecyclable = isRecyclable;
    this.key = key;
    this.listener = Preconditions.checkNotNull(listener);
  }

  Resource<Z> getResource() {
    return resource;
  }

  boolean isMemoryCacheable() {
    return isMemoryCacheable;
  }

  @NonNull
  @Override
  public Class<Z> getResourceClass() {
    return resource.getResourceClass();
  }

  @NonNull
  @Override
  public Z get() {
    return resource.get();
  }

  @Override
  public int getSize() {
    return resource.getSize();
  }

  @Override
  public synchronized void recycle() {
    。。。
    isRecycled = true;
    if (isRecyclable) {
      resource.recycle();
    }
  }

  //获取引用，引用计数+1,一般是新建或者是从pool进行复用，从而增加了引用
  synchronized void acquire() {
    if (isRecycled) {
      throw new IllegalStateException("Cannot acquire a recycled resource");
    }
    ++acquired;
  }

  //释放引用，需要先调用acquire
  void release() {
    boolean release = false;
    synchronized (this) {
      if (acquired <= 0) {
        throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
      }
      if (--acquired == 0) {
        release = true;
      }
    }
    //资源释放回调
    if (release) {
      listener.onResourceReleased(key, this);
    }
  }
}
```


EngineResource使用引用计数对Resource进行监控

牛掰的弱引用复用机制
ResourceWeakReference这个类不简单，它本意是对EngineResource的弱引用，其实在构造它时候，会把EngineResource.resource和EngineResource.key以强引用的形式保存，
所以垃圾回收的是EngineResource，却回收不掉EngineResource.resource，因为此时resource会被ResourceWeakReference引用；
cleanupActiveReference()首先取出ref.resource，这个对象是强引用，不会被回收，被回收的是ref包装的EngineResource;
然后创建新的EngineResource包装真正的resource，最终调用资源回收的监听listener.onResourceReleased(ref.key, newResource)，
而setListener()在Engine构造方法中调用;看一下Engine.onResourceReleased()方法的实现：
```
public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
    //把key对应的ResourceWeakReference从Map中移除
    activeResources.deactivate(cacheKey);
    //复用缓存  禁用MemoryCache后，直接资源回收
    if (resource.isMemoryCacheable()) {
      //回收到MemoryCache
      cache.put(cacheKey, resource);
    } else {
      //进行回收  ResourceRecycler可以处理循环引用的问题//todo
      //回收到BitmapPool
      resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);
    }
  }
```
Engine在onResourceReleased时，重新保存了EngineResource对象,并且在此之前，还调用了activeResources.deactivate(cacheKey)；
为什么要deactivate，下面解释一下原因：
因为在ActiveResources.cleanupActiveReference()中创建新的EngineResource来包装被回收的EngineResource下面的resource,
但是这个resource还在被ref强引用，所以执行activeResources.deactivate(cacheKey)会清除ref多resource的强引用；
弄明白了这些，ActiveResources原理基本上搞明白了；

小结:
ActiveResources采用弱引用的方式，记录EngineResource的回收情况，同时采取强引用保存EngineResource.resource，
在ActiveResources中会有个后台线程会执行清理工作，一旦发现某个EngineResource被回收，就会拿出其对应的resource，
然后创建一个新的EngineResource包装这个resource，之后回调给Engine，让其做内存缓存，
最后Engine调用activeResources.deactivate(cacheKey)解除ref对resource强引用。



内存缓存第二阶段
loadFromCache()流程分析
Engine.java
```
 private EngineResource<?> loadFromCache(Key key) {
    //先从MemoryCache中清除
    EngineResource<?> cached = getEngineResourceFromCache(key);
    //如果命中
    if (cached != null) {    
      //+1操作
      cached.acquire();
      //添加到activeResource
      activeResources.activate(key, cached);
    }
    return cached;
  }
  private EngineResource<?> getEngineResourceFromCache(Key key) {
    //cache为 MemoryCache
    Resource<?> cached = cache.remove(key);

    final EngineResource<?> result;
    if (cached == null) {
      result = null;
    } else if (cached instanceof EngineResource) {
      // Save an object allocation if we've cached an EngineResource (the typical case).
      result = (EngineResource<?>) cached;
    } else {
      result =
          new EngineResource<>(
              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
    }
    return result;
  }
```
loadFromCache()调用getEngineResourceFromCache()返回cached，如果命中，cached+1，然后把cached存放到activeResources缓存中，
getEngineResourceFromCache()主要是调用MemoryCache.remove()返回cached，然后在转成EngineResource返回，
主要逻辑还是在MemoryCache中；
```
public interface MemoryCache {
  interface ResourceRemovedListener {
    void onResourceRemoved(@NonNull Resource<?> removed);
  }

  long getCurrentSize();

  long getMaxSize();

  void setSizeMultiplier(float multiplier);
  //获取Resource并从缓存中移除
  Resource<?> remove(@NonNull Key key);

  Resource<?> put(@NonNull Key key, @Nullable Resource<?> resource);

  void setResourceRemovedListener(@NonNull ResourceRemovedListener listener);

  void clearMemory();

  void trimMemory(int level);
}
```
MemoryCache的实现类是MemoryCacheAdapter与LruResourceCache  MemoryCacheAdapter没有实现缓存功能，获取时返回null
LruResourceCache
MemoryCache是一个接口，Engine中使用的cache是在GlideBuilder中创建，默认实现类是LruResourceCache；

LruResourceCache.java
```
public class LruResourceCache extends LruCache<Key, Resource<?>> implements MemoryCache {
  private ResourceRemovedListener listener;
  //设置缓存大小
  public LruResourceCache(long size) {
    super(size);
  }

  @Override
  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {
    this.listener = listener;
  }

//淘汰当前item时调用
  @Override
  protected void onItemEvicted(@NonNull Key key, @Nullable Resource<?> item) {
    if (listener != null && item != null) {
      listener.onResourceRemoved(item);
    }
  }

  @Override
  protected int getSize(@Nullable Resource<?> item) {
    if (item == null) {
      return super.getSize(null);
    } else {
      return item.getSize();
    }
  }

  @Override
  public void trimMemory(int level) {
    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {
      // Entering list of cached background apps
      // Evict our entire bitmap cache
      clearMemory();
    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN
        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {
      // The app's UI is no longer visible, or app is in the foreground but system is running
      // critically low on memory
      // Evict oldest half of our bitmap cache
      trimToSize(getMaxSize() / 2);
    }
  }
}

```
LruCache的大小
```
public class LruCache<T, Y> {
  //记录访问顺序的LinkedHashMap，访问过的放在链表尾部
  private final Map<T, Entry<Y>> cache = new LinkedHashMap<>(100, 0.75f, true);
  protected void onItemEvicted(@NonNull T key, @Nullable Y item) {
    // optional override
  }
  
  public synchronized Y put(@NonNull T key, @Nullable Y item) {
    final int itemSize = getSize(item);
    //如果item太大，不存入缓存，并回调onItemEvicted
    if (itemSize >= maxSize) {
      onItemEvicted(key, item);
      return null;
    }

    if (item != null) {
      currentSize += itemSize;
    }
    //放入cache中
    Entry<Y> old = cache.put(key, item == null ? null : new Entry<>(item, itemSize));
    if (old != null) {
      currentSize -= old.size;

      if (!old.value.equals(item)) {
        onItemEvicted(key, old.value);
      }
    }
    //校验大小
    evict();
 
    return old != null ? old.value : null;
  }
  
  private void evict() {
    trimToSize(maxSize);
  }
  
  protected synchronized void trimToSize(long size) {
    Map.Entry<T, Entry<Y>> last;
    Iterator<Map.Entry<T, Entry<Y>>> cacheIterator;
    while (currentSize > size) {
      //最新访问过的放在尾部，淘汰头部最老的
      cacheIterator = cache.entrySet().iterator();
      last = cacheIterator.next();
      final Entry<Y> toRemove = last.getValue();
      currentSize -= toRemove.size;
      final T key = last.getKey();
      cacheIterator.remove();
      onItemEvicted(key, toRemove.value);
    }
  }
}
```
LruResourceCache继承LruCache，LruCache利用LinkedHashMap实现LRU功能
//todo LruResourceCache没有重写MemoryCache方法，父类定义相同的方法但是没有实现MemoryCache方法，此时Java如何调用

LruResourceCache继承LruCache并实现MemoryCache接口，缓存的真正实现在LruCache中，这个类是Glide自己实现的，同样基于LikeHashMap，
没什么特殊点，不过可以看出，item缓存大小的计算放在resource自身，除此之外还有一个setResourceRemovedListener()方法，
用来监听资源被淘汰时的回调；
LruResourceCache允许的最大size在构造方法中传入，从GlideBuilder中可以看出是MemorySizeCalculator.getMemoryCacheSize()决定，
MemorySizeCalculator有默认的缓存大小计算规则；  更多可以查看池化pool.md
MemorySizeCalculator.java
```
MemorySizeCalculator(MemorySizeCalculator.Builder builder) {
  ...  
  int widthPixels = builder.screenDimensions.getWidthPixels();
   int heightPixels = builder.screenDimensions.getHeightPixels();
   int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;
  //MEMORY_CACHE_TARGET_SCREENS = 2
  int targetMemoryCacheSize = Math.round(screenSize * builder.memoryCacheScreens);
    int availableSize = maxSize - arrayPoolSize;

    if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {
      memoryCacheSize = targetMemoryCacheSize;
      bitmapPoolSize = targetBitmapPoolSize;
    } else {
      float part = availableSize / (builder.bitmapPoolScreens + builder.memoryCacheScreens);
      memoryCacheSize = Math.round(part * builder.memoryCacheScreens);
      bitmapPoolSize = Math.round(part * builder.bitmapPoolScreens);
    }
}

public int getMemoryCacheSize() {
    //默认为screenSize*2
    return memoryCacheSize;
  }
```
LruResourceCache基本上就是正常的LruCache；保存的是Resource，并不是Bitmap，到现在我们还没有看到Bitmap;



内存缓存小结
上面分析了ActiveResources缓存和MemoryCache缓存，分别使用弱引用技术和LRU技术，构成两级内存缓存，两者有相似之外却又截然不同。

相同之处：都是基于内存做缓存，运行在主线程；
不同之处：ActiveResources依赖垃圾回收机制做淘汰运算，MemoryCache是强引用有最大内存限制，根据最近最少使用规则来淘汰
优先级：ActiveResources优先级高于MemoryCache，ActiveResources当中保存的是活动对象，在ActiveResources某个item被回收时，
  如果其对应的真正的Resource没有被回收，会下放到MemoryCache当中，当然，从MemoryCache中取出的值，会存放在ActiveResources中；

https://juejin.cn/post/7039524495077408805
为什么要有活动资源缓存?
活动资源缓存的存在以较小的代价减小Lru缓存的压力，提升Lru缓存的效率。
原因是活动资源缓存通过缓存的对象本身就是在内存中进行使用，缓存是只是建立一个弱引用关系。如果过没有活动资源缓存，每一次使用的资源都加入内存缓存，
极有可能因为放入Lru缓存的数据过多，导致正在使用资源从Lru缓存中移除，等到下次来进行加载的时候因为没有对应的引用关系，
找不到原来内存中正在使用的那个资源，从而需要再次从文件或者网络进行数据加载。这样同一份资源需要使用两处或者多处内存。大大的提高了内存消耗。
总而言之，活动资源缓存以较小的代价提高了Lru缓存的使用效率，防止加载中的资源被lru回收。

https://jishuin.proginn.com/p/763bfbd664ba
LruCache算法的实现，你会发现它其实是用一个LinkedHashMap来缓存对象的，每次内存超出缓存设定的时候，就会把最近最少使用的缓存去掉，
因此有可能会把正在使用的缓存给误伤了，我还在用着它呢就给移出去了。因此这个弱引用可能是对正在使用中的图片的一种保护，
使用的时候先从LruCache里面移出去，用完了再把它重新加到缓存里面

比如我们 Lru 内存缓存 size 设置装 99 张图片，在滑动 RecycleView 的时候，如果刚刚滑动到 100 张，那么就会回收掉我们已经加载出来的第一张，
这个时候如果返回滑动到第一张，会重新判断是否有内存缓存，如果没有就会重新开一个 Request 请求，
很明显这里如果清理掉了第一张图片并不是我们要的效果。所以在从内存缓存中拿到资源数据的时候就主动添加到活动资源中，并且清理掉内存缓存中的资源。
这么做很显然好处是 保护不想被回收掉的图片不被 LruCache 算法回收掉,充分利用了资源
//LRU内存缓存将老的资源存入到活动缓存；活动缓存引用计数归0,将资源放到LRU内存缓存，重复循环
//什么时候缓存清空？
onTrimMemory  减少或者清空LruResourceCache   memoryCache.trimMemory(level);
onLowMemory  清空


磁盘缓存DiskCache
Glide的DiskCacheStrategy规则：
DiskCacheStrategy.NONE 不进行Disk缓存
DiskCacheStrategy.DATA 只缓存原图
DiskCacheStrategy.RESOURCE 只缓存多尺寸的图片
DiskCacheStrategy.ALL 原图和其他尺寸的图片都缓存
DiskCacheStrategy.AUTOMATIC 自动(默认行为)
Glide支持缓存多尺寸图片的，这就加大了读取缓存的复杂程度；
DiskCacheStrategy磁盘缓存策略的结构
```
public abstract class DiskCacheStrategy {
  public abstract boolean isDataCacheable(DataSource dataSource);

  public abstract boolean isResourceCacheable(
      boolean isFromAlternateCacheKey, DataSource dataSource, EncodeStrategy encodeStrategy);

  public abstract boolean decodeCachedResource();

  public abstract boolean decodeCachedData();
}
```

DecodeJob.java
```
//Stage表示当前run执行到哪一步骤
  private enum Stage {
    INITIALIZE,//初始状态
    RESOURCE_CACHE,//剪裁图Disk缓存
    DATA_CACHE,//原图Disk缓存
    SOURCE,//远程图片
    ENCODE,//解析状态
    FINISHED,//完成
  }

 private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        //如果支持多尺寸，下一个state就是RESOURCE_CACHE,否则，从RESOURCE_CACHE开始往下判断
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE
            : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        //如果支持原图尺寸，下一个state就是DATA_CACHE,否则，从DATA_CACHE开始往下判断
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE
            : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        //如果只读缓存，Stage=FINISHED，否则就是SOURCE
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException("Unrecognized stage: " + current);
    }
  }
  
  private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        //多尺寸对应的  对应资源转换后的
        return new ResourceCacheGenerator(decodeHelper, this);
      case DATA_CACHE:
        //原图对应的
        return new DataCacheGenerator(decodeHelper, this);
      case SOURCE:
        //远程图片对应的
        return new SourceGenerator(decodeHelper, this);
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException("Unrecognized stage: " + stage);
    }
  }
```
其中ResourceCacheGenerator，DataCacheGenerator，SourceGenerator都继承DataFetcherGenerator接口
```
interface DataFetcherGenerator {

  interface FetcherReadyCallback {

    void reschedule();

    void onDataFetcherReady(
        Key sourceKey,
        @Nullable Object data,
        DataFetcher<?> fetcher,
        DataSource dataSource,
        Key attemptedKey);

    void onDataFetcherFailed(
        Key attemptedKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource);
  }

  boolean startNext();

  void cancel();
}

```

在获取CACHE阶段，每个Stage对应了一个DataFetcherGenerator,真正触发加载缓存的逻辑在DataFetcherGenerator中，
再回到runWrapped()方法,假设当前stage为INITIALIZE,且用户设置了多尺寸缓存，这样调用getNextStage(Stage.INITIALIZE)时应该
得到下一个stage是Stage.RESOURCE_CACHE，从而得到ResourceCacheGenerator对象，剩下就是执行runGenerators()方法：
```
private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }
  
 private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
   //循环执行Generators  
    while (!isCancelled
        && currentGenerator != null
        && !(isStarted = currentGenerator.startNext())) {
      //循环查找缓存过程  
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        reschedule();
        return;
      }
    }
    // We've run out of stages and generators, give up.
    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
      notifyFailed();
    }

    // Otherwise a generator started a new load and we expect to be called back in
    // onDataFetcherReady.
  }  
```
在runGenerators()方法中有一个while循环，推进了stage的前进，循环的主要的判断是currentGenerator.startNext()，
  而这个startNext()方法又是读取Cache的新开端。
上面说到根据不同的stage创建不同的Generator，我们仅以SourceGenerator来分析；
获取数据：以SourceGenerator为例   
SourceGenerator.java
```
class SourceGenerator implements DataFetcherGenerator, DataFetcherGenerator.FetcherReadyCallback {
  private static final String TAG = "SourceGenerator";

  private final DecodeHelper<?> helper;
  private final FetcherReadyCallback cb;

  private int loadDataListIndex;
  private DataCacheGenerator sourceCacheGenerator;
  private Object dataToCache;
  private volatile ModelLoader.LoadData<?> loadData;
  private DataCacheKey originalKey;

  SourceGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {
    this.helper = helper;
    this.cb = cb;
  }

  @Override
  public boolean startNext() {
    if (dataToCache != null) {
      Object data = dataToCache;
      dataToCache = null;
      //通过DiskCache缓存data
      //创建sourceCacheGenerator为DataCacheGenerator
      cacheData(data);
    }
    //有缓存从缓存中获取
    if (sourceCacheGenerator != null && sourceCacheGenerator.startNext()) {
      return true;
    }
    sourceCacheGenerator = null;

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      //获取loadData
      loadData = helper.getLoadData().get(loadDataListIndex++);
      if (loadData != null
          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
        started = true;
        ////通过loadData.fetcher获取
        startNextLoad(loadData);
      }
    }
    return started;
  }

  private void startNextLoad(final LoadData<?> toStart) {
    loadData.fetcher.loadData(
        helper.getPriority(),
        new DataCallback<Object>() {
          @Override
          public void onDataReady(@Nullable Object data) {
            if (isCurrentRequest(toStart)) {
              //获取dataToCache
              onDataReadyInternal(toStart, data);
            }
          }

          @Override
          public void onLoadFailed(@NonNull Exception e) {
            if (isCurrentRequest(toStart)) {
              onLoadFailedInternal(toStart, e);
            }
          }
        });
  }

  // We want reference equality explicitly to make sure we ignore results from old requests.
  @SuppressWarnings({"PMD.CompareObjectsWithEquals", "WeakerAccess"})
  @Synthetic
  boolean isCurrentRequest(LoadData<?> requestLoadData) {
    LoadData<?> currentLoadData = loadData;
    return currentLoadData != null && currentLoadData == requestLoadData;
  }
  //判断是否还有下一个ModelLoader
  private boolean hasNextModelLoader() {
    return loadDataListIndex < helper.getLoadData().size();
  }

  //缓存data
  private void cacheData(Object dataToCache) {
    long startTime = LogTime.getLogTime();
    try {
      Encoder<Object> encoder = helper.getSourceEncoder(dataToCache);
      DataCacheWriter<Object> writer =
          new DataCacheWriter<>(encoder, dataToCache, helper.getOptions());
      originalKey = new DataCacheKey(loadData.sourceKey, helper.getSignature());
      //缓存原始data   这里将原始数据写入文件中了
      helper.getDiskCache().put(originalKey, writer);
      ...
    } finally {
      loadData.fetcher.cleanup();
    }
    //创建DataCacheGenerator
    sourceCacheGenerator =
        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, this);
  }

  @Synthetic
  void onDataReadyInternal(LoadData<?> loadData, Object data) {
    DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();
    if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {
      dataToCache = data;
      // We might be being called back on someone else's thread. Before doing anything, we should
      // reschedule to get back onto Glide's thread.
      cb.reschedule();
    } else {
      cb.onDataFetcherReady(
          loadData.sourceKey,
          data,
          loadData.fetcher,
          loadData.fetcher.getDataSource(),
          originalKey);
    }
  }

  @SuppressWarnings("WeakerAccess")
  @Synthetic
  void onLoadFailedInternal(LoadData<?> loadData, @NonNull Exception e) {
    cb.onDataFetcherFailed(originalKey, e, loadData.fetcher, loadData.fetcher.getDataSource());
  }

  @Override
  public void reschedule() {
    // We don't expect this to happen, although if we ever need it to we can delegate to our
    // callback.
    throw new UnsupportedOperationException();
  }

  // Called from source cache generator.
  @Override
  public void onDataFetcherReady(
      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
    // This data fetcher will be loading from a File and provide the wrong data source, so override
    // with the data source of the original fetcher
    cb.onDataFetcherReady(sourceKey, data, fetcher, loadData.fetcher.getDataSource(), sourceKey);
  }

  @Override
  public void onDataFetcherFailed(
      Key sourceKey, Exception e, DataFetcher<?> fetcher, DataSource dataSource) {
    cb.onDataFetcherFailed(sourceKey, e, fetcher, loadData.fetcher.getDataSource());
  }
}
```
cacheData通过DiskCache缓存数据，并生成DataCacheGenerator
```
class DataCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
    public boolean startNext() {
    while (modelLoaders == null || !hasNextModelLoader()) {
      sourceIdIndex++;
      if (sourceIdIndex >= cacheKeys.size()) {
        return false;
      }

      Key sourceId = cacheKeys.get(sourceIdIndex);
      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());
      //获取缓存文件
      cacheFile = helper.getDiskCache().get(originalKey);
      if (cacheFile != null) {
        this.sourceKey = sourceId;
        modelLoaders = helper.getModelLoaders(cacheFile);
        modelLoaderIndex = 0;
      }
    }

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
      //将cacheFile转为loadData
      loadData =
          modelLoader.buildLoadData(
              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
        started = true;
        //加载file
        loadData.fetcher.loadData(helper.getPriority(), this);
      }
    }
    return started;
  }
}
```
SourceGenerator实现DataFetcherGenerator接口，主要代码在startNext()方法当中，startNext()最前面会判断数据是否已经在缓存中，
缓存存在直接调用cacheData()创建DataCacheGenerator，最终会执行这个Generator的startNext()方法，否则，while循环获取loadData，
如果满足条件，执行loadData.fetcher.loadData(helper.getPriority(), this);，最后一个参数this是DataFetcher.DataCallback回调接口，
获取成功会回调onDataReady(Object data)方法;

onDataReady对数据是否只从缓存做判断，因为当前是获取数据源的数据，如果支持disk缓存，回调cb.reschedule(),否则，
回调cb.onDataFetcherReady，那么这个cb是谁？
cb是FetcherReadyCallback类型，这个cb在SourceGenerator构造方法中传入，SourceGenerator是在DecodeJob中创建的，
真正是cb是DecodeJob，所以代码定位到DecodeJob.onDataFetcherReady()和reschedule()方法.

DecodeJob.java
```
  public void reschedule() {
    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
    //callback是EngineJob
    callback.reschedule(this);
  }
  
  public void onDataFetcherReady(
      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
    this.currentSourceKey = sourceKey;
    this.currentData = data;
    this.currentFetcher = fetcher;
    this.currentDataSource = dataSource;
    this.currentAttemptingKey = attemptedKey;
    this.isLoadingFromAlternateCacheKey = sourceKey != decodeHelper.getCacheKeys().get(0);

    if (Thread.currentThread() != currentThread) {
      runReason = RunReason.DECODE_DATA;
      callback.reschedule(this);//解析数据，
    } else {
      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");
      try {
        //真正的解析数据，上面的if最终也会走到这里
        decodeFromRetrievedData();
      } finally {
        GlideTrace.endSection();
      }
    }
  }
```

在reschedule()方法中,首先将runReason推进到SWITCH_TO_SOURCE_SERVICE，然后调用EngineJob.reschedule(this)，最终还会再次走到run()方法，
不同的是在EngineJob中为decodeJob重新分配了线程池，另一个不同是runReason;
在onDataFetcherReady()方法中，会判断当前线程池，如果不符合条件，也会将runReason推进到DECODE_DATA，
然后执行EngineJob.reschedule(this)，流程和reschedule()回调方法一样，最终会重新走run()方法，run()方法会根据runReason判断逻辑，
如果在当前线程池，直接调用decodeFromRetrievedData();
我们上面只分析了onDataFetcherReady()也就是数据成功的情况，失败的情况暂时不讨论了，总结一下SourceGenerator的主要流程：

通过 helper.getLoadData()获取loadData,调用loadData.fetcher.loadData()来执行load;
DecodeJob接受load回调，如果需要进行cache，回调EngineJob执行cache相关的Generator；
如果可以解析，调用decodeFromRetrievedData()做解析工作；

看一下ResourceCacheGenerator
https://juejin.cn/post/6844903953604280328#heading-11
```
class ResourceCacheGenerator implements DataFetcherGenerator, DataFetcher.DataCallback<Object> {
public boolean startNext() {
    List<Key> sourceIds = helper.getCacheKeys();
    if (sourceIds.isEmpty()) {
      return false;
    }
    List<Class<?>> resourceClasses = helper.getRegisteredResourceClasses();
    if (resourceClasses.isEmpty()) {
      if (File.class.equals(helper.getTranscodeClass())) {
        return false;
      }
      throw new IllegalStateException(
       ....
    }
    while (modelLoaders == null || !hasNextModelLoader()) {
      resourceClassIndex++;
      if (resourceClassIndex >= resourceClasses.size()) {
        sourceIdIndex++;
        if (sourceIdIndex >= sourceIds.size()) {
          return false;
        }
        resourceClassIndex = 0;
      }

      Key sourceId = sourceIds.get(sourceIdIndex);
      Class<?> resourceClass = resourceClasses.get(resourceClassIndex);
      Transformation<?> transformation = helper.getTransformation(resourceClass);
     
      currentKey =
          new ResourceCacheKey( // NOPMD AvoidInstantiatingObjectsInLoops
              helper.getArrayPool(),
              sourceId,
              helper.getSignature(),
              helper.getWidth(),
              helper.getHeight(),
              transformation,
              resourceClass,
              helper.getOptions());
      //获取缓存        
      cacheFile = helper.getDiskCache().get(currentKey);
      if (cacheFile != null) {
        sourceKey = sourceId;
        modelLoaders = helper.getModelLoaders(cacheFile);
        modelLoaderIndex = 0;
      }
    }

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      // 获取一个数据加载器
      ModelLoader<File, ?> modelLoader = modelLoaders.get(modelLoaderIndex++);
      //将cacheFile转为loadData
      //为资源缓存文件，构建一个加载器，这是构建出来的是 ByteBufferFileLoader 的内部类 ByteBufferFetcher
      loadData =
          modelLoader.buildLoadData(
              cacheFile, helper.getWidth(), helper.getHeight(), helper.getOptions());
      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {
        started = true;
        //加载file为data
        //用 ByteBufferFetcher 加载，最后把结果会通过回调给 DecodeJob 的 onDataFetcherReady 函数
        loadData.fetcher.loadData(helper.getPriority(), this);
      }
    }

    return started;
  }
}
```
DecodeJob的处理
com/bumptech/glide/load/engine/DecodeJob.java
```
public void onDataFetcherReady(
      Key sourceKey, Object data, DataFetcher<?> fetcher, DataSource dataSource, Key attemptedKey) {
    ...
        decodeFromRetrievedData();
     ...
  }
  
   private void decodeFromRetrievedData() {
    ....
    Resource<R> resource = null;
    try {
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } catch (GlideException e) {
     ...
    }
    if (resource != null) {
      notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);
    } else {
      runGenerators();
    }
  }

  private void notifyEncodeAndRelease(
      Resource<R> resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) {
   ...
    stage = Stage.ENCODE;
    try {
      //是否可以将转换后的图片缓存
      if (deferredEncodeManager.hasResourceToEncode()) {
        // 缓存入口  DecodeJob.DeferredEncodeManager<?> deferredEncodeManager
        deferredEncodeManager.encode(diskCacheProvider, options);
      }
    } finally {
      ....
    }
    // Call onEncodeComplete outside the finally block so that it's not called if the encode process
    // throws.
    onEncodeComplete();
  }
  
  void encode(DiskCacheProvider diskCacheProvider, Options options) {
      GlideTrace.beginSection("DecodeJob.encode");
      try {
        //将 Bitmap 缓存到资源磁盘
        diskCacheProvider
            .getDiskCache()
            .put(key, new DataCacheWriter<>(encoder, toEncode, options));
      } finally {
        ...
      }
    }
 
 encoder, toEncode的初始化
 <Z> Resource<Z> onResourceDecoded(DataSource dataSource, @NonNull Resource<Z> decoded) {
    @SuppressWarnings("unchecked")
    Class<Z> resourceSubClass = (Class<Z>) decoded.get().getClass();
    Transformation<Z> appliedTransformation = null;
    Resource<Z> transformed = decoded;
    if (dataSource != DataSource.RESOURCE_DISK_CACHE) {
      appliedTransformation = decodeHelper.getTransformation(resourceSubClass);
      //应用变换transform
      transformed = appliedTransformation.transform(glideContext, decoded, width, height);
    }
    if (!decoded.equals(transformed)) {
      decoded.recycle();
    }

    final EncodeStrategy encodeStrategy;
    final ResourceEncoder<Z> encoder;
    if (decodeHelper.isResourceEncoderAvailable(transformed)) {
      encoder = decodeHelper.getResultEncoder(transformed);
      encodeStrategy = encoder.getEncodeStrategy(options);
    } else {
      encoder = null;
      encodeStrategy = EncodeStrategy.NONE;
    }

    Resource<Z> result = transformed;
    boolean isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);
    if (diskCacheStrategy.isResourceCacheable(
        isFromAlternateCacheKey, dataSource, encodeStrategy)) {
      if (encoder == null) {
        throw new Registry.NoResultEncoderAvailableException(transformed.get().getClass());
      }
      final Key key;
      switch (encodeStrategy) {
        case SOURCE:
          key = new DataCacheKey(currentSourceKey, signature);
          break;
        case TRANSFORMED: //上面存在bimap的变换应用 transform  类型为ResourceCacheKey
          key =
              new ResourceCacheKey(
                  decodeHelper.getArrayPool(),
                  currentSourceKey,
                  signature,
                  width,
                  height,
                  appliedTransformation,
                  resourceSubClass,
                  options);
          break;
      }

      LockedResource<Z> lockedResult = LockedResource.obtain(transformed);
      deferredEncodeManager.init(key, encoder, lockedResult);
      result = lockedResult;
    }
    return result;
  }   
```
http 请求到图片输入流之后经过一系列处理，转换得到目标 Bitmap 资源，最后通过回调到 DecodeJob 进行缓存起来
//下采样处理后图片缓存  transform的处理

