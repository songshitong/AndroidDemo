



IOCanary分为四个检测场景：主线程I/O、读写Buffer过小、重复读、Closeable泄漏监控
前面三个可以采用native hook(xHook框架)的方式收集I/O信息，在close操作时计算并上报。后者可以借StrictMode的东风，
这是Android系统底层自带的监控，通过简单的hook可以将CloseGuard#reporter替换成自己的实现，然后在其report函数中完成上报即可

主线程I/O
主线程 I/O ，代码里面判定的规则如下：
单次读写最长耗时不得超过13ms
或者连续读写最长耗时不得超过500ms

耗时的 IO 操作不能占据主线程太久。检测条件：
1. 操作线程为主线程
2. 连续读写耗时超过一定阈值或单次 write\read 耗时超过一定阈值

读写Buffer过小
读写Buffer过小，代码里面判定的规则如下：
1 文件累计读写次数超过20次
2 且平均读写buffer小于4096
3 且文件最大连续读写耗时大于等于13ms

Buffer 过小，会导致 read/write 的次数增多，从而影响了性能。
多次执行io，io的速度比cpu小很多，代码执行时间会变长
设置buffer后，会先将内容写入buffer，然后整体写入磁盘，默认的Output流没有缓冲
检测条件：
1. buffer 小于一定阈值
2. read/write 的次数超过一定的阈值

重复读
重复读的检测相对于上面两个检测来说，就复杂那么一丢丢。原因在于重复读检测的不仅仅是文件的一个生命周期，而是需要保存一次次检测的输入文件，
然后再整个应用的生命周期内进行检测。

那么，略过一些准备工作，重复读的核心检测语句，在代码里面判定的规则如下：
1 同一文件两次检测的间隔不超过17ms
2 且文件在同一位置(堆栈判断)读取次数超过5次