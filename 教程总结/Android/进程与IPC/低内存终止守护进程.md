https://developer.android.com/topic/performance/memory-management?hl=zh-cn#memory_pages

//todo 匿名页  kswapd

android进程
https://juejin.cn/post/6844904136937324552  todo五种进程的定义   进程管理？  ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理
https://www.jianshu.com/p/21e96ba33688
五种进程
第一高：前台进程 前台进程是Android系统中最重要的进程，是与用户正在交互的进程。
用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程
  托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）
  托管某个 Service，后者绑定到用户正在交互的 Activity
  托管正在“前台”运行的 Service（服务已调用 startForeground()）
  托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
  托管正执行其 onReceive() 方法的 BroadcastReceiver
通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 
     此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。

第二高：可见进程 可见进程指部分程序界面能够被用户看见，却不在前台与用户交互。
  没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：
  托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，
     允许在其后显示上一 Activity，则有可能会发生这种情况。
    我们在一个界面上弹出一个对话框（该对话框是一个新的Activity），那么在对话框后面的原界面是可见的，但是并没有与用户进行交互，
      那么原界面就是可见进程
  托管绑定到可见（或前台）Activity 的 Service。
可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程

第三高：服务进程 一个包含已启动服务的进程就是服务进程，服务没有用户界面，不与用户直接交互，但能够在后台长期运行，提供用户所关心的重要功能。
  例如，在后台播放音乐或从网络下载数据。除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。

第四高：后台进程 如果一个进程不包含任何已经启动的服务，而且没有用户可见的Activity，则这个进程就是后台进程。
  通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。
  如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，
  因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。


第五高：空进程空进程是不包含任何活跃组件的进程。在系统资源紧张时会被首先清除。


android-13.0.0_r1    不同版本adj值不同
http://gityuan.com/2016/08/07/android-adj/
Adj
定义在ProcessList.java文件。adj值越大，优先级越低，adj<0的进程都是系统进程。
frameworks/base/services/core/java/com/android/server/am/ProcessList.java
```
ADJ级别	              取值	  解释
UNKNOWN_ADJ	          1001	  一般指将要会缓存进程，无法获取确定值
CACHED_APP_MAX_ADJ	   999	  不可见进程的adj最大值
CACHED_APP_MIN_ADJ	  900 	  不可见进程的adj最小值
SERVICE_B_ADJ	        800	  B List中的Service（较老的、使用可能性更小）
PREVIOUS_APP_ADJ	   700	  上一个App的进程(往往通过按返回键)
HOME_APP_ADJ	       600	 Home进程
SERVICE_ADJ	           500	 服务进程(Service process)
HEAVY_WEIGHT_APP_ADJ	400	 后台的重量级进程，system/rootdir/init.rc文件中设置
BACKUP_APP_ADJ	        300	 备份进程
PERCEPTIBLE_APP_ADJ	    200	 可感知进程，比如后台音乐播放
PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ 50 从前台应用到前台服务
VISIBLE_APP_ADJ	        100	可见进程(Visible process)
FOREGROUND_APP_ADJ	    0	前台进程（Foreground process)
PERSISTENT_SERVICE_ADJ	-700	关联着系统或persistent进程
PERSISTENT_PROC_ADJ	    -800 系统persistent进程，比如telephony
SYSTEM_ADJ	          -900	系统进程
NATIVE_ADJ	-1000    	native进程（不被系统管理）
```

ProcessState
定义在ActivityManager.java文件，process_state划分18类

//frameworks/base/core/java/com/android/internal/app/procstats/ProcessState.java
frameworks/base/core/java/com/android/internal/app/procstats/ProcessStats.java
```
state级别	                          取值	解释
STATE_CACHED_EMPTY	          15	进程处于cached状态，且为空进程
STATE_CACHED_ACTIVITY_CLIENT	14	进程处于cached状态，且为另一个cached进程(内含Activity)的client进程
STATE_CACHED_ACTIVITY	       13	进程处于cached状态，且内含Activity
STATE_LAST_ACTIVITY	           12	后台进程，且拥有上一次显示的Activity
STATE_HOME	                   11   后台进程，且拥有home Activity
STATE_RECEIVER	               9	后台进程，且正在运行receiver
STATE_SERVICE	               7	后台进程，且正在运行service
STATE_HEAVY_WEIGHT	           10	后台进程，但无法执行restore，因此尽量避免kill该进程
STATE_BACKUP	               6	后台进程，正在运行backup/restore操作
STATE_IMPORTANT_BACKGROUND	   5	对用户很重要的进程，用户不可感知其存在
STATE_IMPORTANT_FOREGROUND	   4	对用户很重要的进程，用户可感知其存在
//STATE_TOP_SLEEPING	5	与PROCESS_STATE_TOP一样，但此时设备正处于休眠状态
//STATE_FOREGROUND_SERVICE	4	拥有一个前台Service
//STATE_BOUND_FOREGROUND_SERVICE	3	拥有一个前台Service，且由系统绑定
STATE_TOP	                   1	拥有当前用户可见的top Activity
//STATE_PERSISTENT_UI	1	persistent系统进程，并正在执行UI操作
STATE_PERSISTENT	         0	persistent系统进程
//STATE_NONEXISTENT	         -1	不存在的进程state级别	取值	解释
```

三大护法
调整进程的adj的3大护法, 也就是ADJ算法的核心方法:
updateOomAdjLocked：更新adj，当目标进程为空，或者被杀则返回false；否则返回true;
computeOomAdjLocked：计算adj，返回计算后RawAdj值;
applyOomAdjLocked：应用adj，当需要杀掉目标进程则返回false；否则返回true。
前面提到调整adj的3大护法，最为常见的方法便是updateOomAdjLocked，这也是其他各个方法在需要更新adj时会调用的方法，该方法有3个不同参数的同名方法，定义如下：
```
无参方法：updateOomAdjLocked()
一参方法：updateOomAdjLocked(ProcessRecord app)
五参方法：updateOomAdjLocked(ProcessRecord app, int cachedAdj,
    ProcessRecord TOP_APP, boolean doingAll, long now)
```
updateOomAdjLocked实现过程中依次会computeOomAdjLocked和applyOomAdjLocked。


ADJ的更新时机
先来说说哪些场景下都会触发updateOomAdjLocked来更新进程adj:

2.1 Activity
ASS.realStartActivityLocked: 启动Activity
AS.resumeTopActivityInnerLocked: 恢复栈顶Activity
AS.finishCurrentActivityLocked: 结束当前Activity
AS.destroyActivityLocked: 摧毁当前Activity
2.2 Service
位于ActiveServices.java
realStartServiceLocked: 启动服务
bindServiceLocked: 绑定服务(只更新当前app)
unbindServiceLocked: 解绑服务 (只更新当前app)
bringDownServiceLocked: 结束服务 (只更新当前app)
sendServiceArgsLocked: 在bringup或则cleanup服务过程调用 (只更新当前app)
2.3 broadcast
BQ.processNextBroadcast: 处理下一个广播
BQ.processCurBroadcastLocked: 处理当前广播
BQ.deliverToRegisteredReceiverLocked: 分发已注册的广播 (只更新当前app)
2.4 ContentProvider
AMS.removeContentProvider: 移除provider
AMS.publishContentProviders: 发布provider (只更新当前app)
AMS.getContentProviderImpl: 获取provider (只更新当前app)
2.5 Process
位于ActivityManagerService.java
setSystemProcess: 创建并设置系统进程
addAppLocked: 创建persistent进程
attachApplicationLocked: 进程创建后attach到system_server的过程;
trimApplications: 清除没有使用app
appDiedLocked: 进程死亡
killAllBackgroundProcesses: 杀死所有后台进程.即(ADJ>9或removed=true的普通进程)
killPackageProcessesLocked: 以包名的形式 杀掉相关进程;


updateOomAdjLocked   
在介绍updateOomAdjLocked方法之前,先简单介绍这个过程会遇到的比较重要的参数.
frameworks/base/services/core/java/com/android/server/am/ActivityManagerConstants.java
空进程存活时长： MAX_EMPTY_TIME = 30min
(缓存+空)进程个数上限：MAX_CACHED_PROCESSES = SystemProperties.getInt(“sys.fw.bg_apps_limit”,32) = 32(默认)；
空进程个数上限：CUR_MAX_EMPTY_PROCESSES  = computeEmptyProcessLimit(MAX_CACHED_APPS) = MAX_CACHED_APPS/2 = 16；
trim空进程个数上限：CUR_TRIM_EMPTY_PROCESSES  = computeEmptyProcessLimit(MAX_CACHED_PROCESSES) / 2 = 8；
trim缓存进程个数上限：  CUR_TRIM_CACHED_PROCESSES =
(MAX_CACHED_PROCESSES(32) - computeEmptyProcessLimit(MAX_CACHED_PROCESSES)) / 3 = 5;





frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
```
 final void updateOomAdjLocked(String oomAdjReason) {
        mOomAdjuster.updateOomAdjLocked(oomAdjReason);
    }
```
frameworks/base/services/core/java/com/android/server/am/OomAdjuster.java
```
void updateOomAdjLocked(String oomAdjReason) {
        synchronized (mProcLock) {
            updateOomAdjLSP(oomAdjReason);
        }
    }

 private void updateOomAdjLSP(String oomAdjReason) {
       ..
        try {
            mOomAdjUpdateOngoing = true;
            performUpdateOomAdjLSP(oomAdjReason);
        } finally {
           ...
        }
    } 
    
   private void performUpdateOomAdjLSP(String oomAdjReason) {
        final ProcessRecord topApp = mService.getTopApp();
        // Clear any pending ones because we are doing a full update now.
        mPendingProcessSet.clear();
        mService.mAppProfiler.mHasPreviousProcess = mService.mAppProfiler.mHasHomeProcess = false;
        updateOomAdjInnerLSP(oomAdjReason, topApp , null, null, true, true);
    }  
    
 
  private void updateOomAdjInnerLSP(String oomAdjReason, final ProcessRecord topApp,
            ArrayList<ProcessRecord> processes, ActiveUids uids, boolean potentialCycles,
            boolean startProfiling) {
       ..
        final long now = SystemClock.uptimeMillis();
        final long nowElapsed = SystemClock.elapsedRealtime();
        final long oldTime = now - mConstants.mMaxEmptyTimeMillis;
        final boolean fullUpdate = processes == null;
        ActiveUids activeUids = uids;
        ArrayList<ProcessRecord> activeProcesses = fullUpdate ? mProcessList.getLruProcessesLOSP()
                : processes;
        final int numProc = activeProcesses.size();
       ....
       for (int  i = activeUids.size() - 1; i >= 0; i--) {
            final UidRecord uidRec = activeUids.valueAt(i);
            ...
            uidRec.reset(); //重置状态mCurProcState为空进程 ActivityManager.PROCESS_STATE_CACHED_EMPTY
        }

       ...
        for (int i = numProc - 1; i >= 0; i--) {
            ProcessRecord app = activeProcesses.get(i);
            final ProcessStateRecord state = app.mState;
            if (!app.isKilledByAm() && app.getThread() != null) {
                state.setProcStateChanged(false);
                //计算adj
                computeOomAdjLSP(app, ProcessList.UNKNOWN_ADJ, topApp, fullUpdate, now, false,
                        computeClients); // It won't enter cycle if not computing clients.
                // if any app encountered a cycle, we need to perform an additional loop later
                retryCycles |= state.containsCycle();
                // Keep the completedAdjSeq to up to date.
                state.setCompletedAdjSeq(mAdjSeq);
            }
        }

       ...
        boolean allChanged = updateAndTrimProcessLSP(now, nowElapsed, oldTime, activeUids,
                oomAdjReason);
        mNumServiceProcs = mNewNumServiceProcs;
        ...
    }
```
computeOomAdjLSP
空进程情况
```
  private boolean computeOomAdjLSP(ProcessRecord app, int cachedAdj,
            ProcessRecord topApp, boolean doingAll, long now, boolean cycleReEval,
            boolean computeClients) {
    final ProcessStateRecord state = app.mState;
        //已经完成
        if (mAdjSeq == state.getAdjSeq()) {
            if (state.getAdjSeq() == state.getCompletedAdjSeq()) {
                // This adjustment has already been computed successfully.
                return false;
            } else {
                // The process is being computed, so there is a cycle. We cannot
                // rely on this process's state.
                state.setContainsCycle(true);
                mProcessesInCycle.add(app);

                return false;
            }
        }

        // 当进程对象为空时，则设置curProcState=PROCESS_STATE_CACHED_EMPTY， curAdj=CACHED_APP_MAX_ADJ 
        if (app.getThread() == null) {
            ...
            state.setCurProcState(PROCESS_STATE_CACHED_EMPTY);
            state.setCurAdj(ProcessList.CACHED_APP_MAX_ADJ);
            state.setCurRawAdj(ProcessList.CACHED_APP_MAX_ADJ);
            ...
            return false;
        }          
}
```
maxAdj<=0情况
```
final int appUid = app.info.uid;
        final int logUid = mService.mCurOomAdjUid;
        int prevAppAdj = state.getCurAdj();
        int prevProcState = state.getCurProcState();
        int prevCapability = state.getCurCapability();
        final ProcessServiceRecord psr = app.mServices;

        if (state.getMaxAdj() <= ProcessList.FOREGROUND_APP_ADJ) {
            // The max adjustment doesn't allow this app to be anything
            // below foreground, so it is not worth doing work for it.
            if (DEBUG_OOM_ADJ_REASON || logUid == appUid) {
                reportOomAdjMessageLocked(TAG_OOM_ADJ, "Making fixed: " + app);
            }
            state.setAdjType("fixed");
            state.setAdjSeq(mAdjSeq);
            state.setCurRawAdj(state.getMaxAdj());
            state.setHasForegroundActivities(false);
            state.setCurrentSchedulingGroup(ProcessList.SCHED_GROUP_DEFAULT);
            state.setCurCapability(PROCESS_CAPABILITY_ALL);
            state.setCurProcState(ActivityManager.PROCESS_STATE_PERSISTENT);
            state.setSystemNoUi(true);
            //顶部的activity就是当前app，则代表正处于展现UI
            if (app == topApp) {
                state.setSystemNoUi(false);
                state.setCurrentSchedulingGroup(ProcessList.SCHED_GROUP_TOP_APP);
                state.setAdjType("pers-top-activity");
            } else if (state.hasTopUi()) {
                // sched group/proc state adjustment is below
                state.setSystemNoUi(false);
                state.setAdjType("pers-top-ui");
            } else if (state.getCachedHasVisibleActivities()) { //进程中的activity个数大于0时
                state.setSystemNoUi(false);
            }
            if (!state.isSystemNoUi()) {
                if (mService.mWakefulness.get() == PowerManagerInternal.WAKEFULNESS_AWAKE
                        || state.isRunningRemoteAnimation()) {
                    // screen on or animating, promote UI
                    state.setCurProcState(ActivityManager.PROCESS_STATE_PERSISTENT_UI);
                    state.setCurrentSchedulingGroup(ProcessList.SCHED_GROUP_TOP_APP);
                } else {
                    // screen off, restrict UI scheduling
                    state.setCurProcState(PROCESS_STATE_BOUND_FOREGROUND_SERVICE);
                    state.setCurrentSchedulingGroup(ProcessList.SCHED_GROUP_RESTRICTED);
                }
            }
            state.setCurRawProcState(state.getCurProcState());
            state.setCurAdj(state.getMaxAdj());
            state.setCompletedAdjSeq(state.getAdjSeq());
            // if curAdj is less than prevAppAdj, then this process was promoted
            return state.getCurAdj() < prevAppAdj || state.getCurProcState() < prevProcState;
        }
```
当maxAdj <=0的情况，也就意味这不允许app将其adj调整到低于前台app的优先级别, 这样场景下执行后将直接返回:  //adj越小，优先级越高
curProcState =PROCESS_STATE_BOUND_FOREGROUND_SERVICE或 PROCESS_STATE_PERSISTENT_UI(存在visible的activity)
curAdj = app.maxAdj (curAdj<=0)

前台的情况
```
 final int PROCESS_STATE_CUR_TOP = mService.mAtmInternal.getTopProcessState();
        int adj;
        int schedGroup;
        int procState;
        int capability = cycleReEval ? app.mState.getCurCapability() : 0;

        boolean foregroundActivities = false;
        boolean hasVisibleActivities = false;
        if (PROCESS_STATE_CUR_TOP == PROCESS_STATE_TOP && app == topApp) {
            // The last app on the list is the foreground app.
            adj = ProcessList.FOREGROUND_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            state.setAdjType("top-activity");
            foregroundActivities = true;
            hasVisibleActivities = true;
            procState = PROCESS_STATE_CUR_TOP;
            ...
        }else if (state.isRunningRemoteAnimation()) {
            adj = ProcessList.VISIBLE_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            state.setAdjType("running-remote-anim");
            procState = PROCESS_STATE_CUR_TOP;
           ...
        } else if (app.getActiveInstrumentation() != null) {
            adj = ProcessList.FOREGROUND_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            state.setAdjType("instrumentation");
            procState = PROCESS_STATE_FOREGROUND_SERVICE;
           ....
        } else if (state.getCachedIsReceivingBroadcast(mTmpBroadcastQueue)) {
            adj = ProcessList.FOREGROUND_APP_ADJ;
            schedGroup = (mTmpBroadcastQueue.contains(mService.mFgBroadcastQueue))
                    ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
            state.setAdjType("broadcast");
            procState = ActivityManager.PROCESS_STATE_RECEIVER;
           ...
        } else if (psr.numberOfExecutingServices() > 0) {
            adj = ProcessList.FOREGROUND_APP_ADJ;
            schedGroup = psr.shouldExecServicesFg()
                    ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
            state.setAdjType("exec-service");
            procState = PROCESS_STATE_SERVICE;
            ...
        } else if (app == topApp) {
            adj = ProcessList.FOREGROUND_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            state.setAdjType("top-sleeping");
            foregroundActivities = true;
            procState = PROCESS_STATE_CUR_TOP;
            ...
        } else {
            // As far as we know the process is empty.  We may change our mind later.
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            // At this point we don't actually know the adjustment.  Use the cached adj
            // value that the caller wants us to.
            adj = cachedAdj;
            procState = PROCESS_STATE_CACHED_EMPTY;
            if (!state.containsCycle()) {
                state.setCached(true);
                state.setEmpty(true);
                state.setAdjType("cch-empty");
            }
            ...
        } 
```
Case	                         adj	procState
当app是当前展示的app	            adj=0	PROCESS_STATE_CUR_TOP
running-remote-anim             adj=100     PROCESS_STATE_CUR_TOP 
当instrumentation不为空时      	adj=0	PROCESS_STATE_FOREGROUND_SERVICE
当进程存在正在接收的broadcastrecevier	adj=0	PROCESS_STATE_RECEIVER
当进程存在正在执行的service	        adj=0	     PROCESS_STATE_SERVICE
top-sleeping                    adj=0        PROCESS_STATE_CUR_TOP
以上条件都不符合	              adj=cachedAdj(>=0)	PROCESS_STATE_CACHED_EMPTY


非前台activity的情况
```
        if (!foregroundActivities && state.getCachedHasActivities()) {
            state.computeOomAdjFromActivitiesIfNecessary(mTmpComputeOomAdjWindowCallback,
                    adj, foregroundActivities, hasVisibleActivities, procState, schedGroup,
                    appUid, logUid, PROCESS_STATE_CUR_TOP);

            adj = state.getCachedAdj();
            foregroundActivities = state.getCachedForegroundActivities();
            hasVisibleActivities = state.getCachedHasVisibleActivities();
            procState = state.getCachedProcState();
            schedGroup = state.getCachedSchedGroup();
        }
```
frameworks/base/services/core/java/com/android/server/am/ProcessStateRecord.java
```
 void computeOomAdjFromActivitiesIfNecessary(OomAdjuster.ComputeOomAdjWindowCallback callback,
            int adj, boolean foregroundActivities, boolean hasVisibleActivities, int procState,
            int schedGroup, int appUid, int logUid, int processCurTop) {
        if (mCachedAdj != ProcessList.INVALID_ADJ) {
            return;
        }
        callback.initialize(mApp, adj, foregroundActivities, hasVisibleActivities, procState,
                schedGroup, appUid, logUid, processCurTop);
        final int minLayer = Math.min(ProcessList.VISIBLE_APP_LAYER_MAX,
                mApp.getWindowProcessController().computeOomAdjFromActivities(callback));

        mCachedAdj = callback.adj;
        mCachedForegroundActivities = callback.foregroundActivities;
        mCachedHasVisibleActivities = callback.mHasVisibleActivities ? VALUE_TRUE : VALUE_FALSE;
        mCachedProcState = callback.procState;
        mCachedSchedGroup = callback.schedGroup;

        if (mCachedAdj == ProcessList.VISIBLE_APP_ADJ) {
            mCachedAdj += minLayer;
        }
    }
```
主要逻辑都在ComputeOomAdjWindowCallback
frameworks/base/services/core/java/com/android/server/am/OomAdjuster.java
```
final class ComputeOomAdjWindowCallback
            implements WindowProcessController.ComputeOomAdjCallback {
   public void onVisibleActivity() {
            // App has a visible activity; only upgrade adjustment.
            if (adj > ProcessList.VISIBLE_APP_ADJ) {
                adj = ProcessList.VISIBLE_APP_ADJ;
                mState.setAdjType("vis-activity");
               ...
            }
            if (procState > processStateCurTop) {
                //状态为PROCESS_STATE_CUR_TOP
                procState = processStateCurTop;
                mState.setAdjType("vis-activity");
                ...
            }
           ...
        }  
        
   @Override
        public void onPausedActivity() {
            if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                mState.setAdjType("pause-activity");
                ...
            }
            if (procState > processStateCurTop) {
                procState = processStateCurTop;
                mState.setAdjType("pause-activity");
               ...
            }
           ...
        }  
        
   @Override
        public void onStoppingActivity(boolean finishing) {
            if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                mState.setAdjType("stop-activity");
                ...
            }
            if (!finishing) {
                if (procState > PROCESS_STATE_LAST_ACTIVITY) {
                    procState = PROCESS_STATE_LAST_ACTIVITY;
                    mState.setAdjType("stop-activity");
                   ...
                }
            }
           ...
        }
        
    @Override
        public void onOtherActivity() {
            if (procState > PROCESS_STATE_CACHED_ACTIVITY) {
                procState = PROCESS_STATE_CACHED_ACTIVITY;
                mState.setAdjType("cch-act");
              ...
            }
            mHasVisibleActivities = false;
        }                       
}
```
对于进程中的activity处于非前台情况
当activity可见， 则adj=100,procState=PROCESS_STATE_CUR_TOP；
当activity正在暂停或者已经暂停， 则adj=200,procState=PROCESS_STATE_CUR_TOP；
当activity正在停止， 则adj=200,procState=PROCESS_STATE_LAST_ACTIVITY(且activity尚未finish)；
以上都不满足，否则procState=PROCESS_STATE_CACHED_ACTIVITY


adj > 200的情况
```
 if (adj > ProcessList.PERCEPTIBLE_APP_ADJ
                || procState > PROCESS_STATE_FOREGROUND_SERVICE) {
            if (psr.hasForegroundServices()) {
                // 当存在前台service时
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                procState = PROCESS_STATE_FOREGROUND_SERVICE;
                state.setAdjType("fg-service");
                ...
            } else if (state.hasOverlayUi()) {
                // The process is display an overlay UI.
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                procState = PROCESS_STATE_IMPORTANT_FOREGROUND;
                ...
            }
        }

if (psr.hasForegroundServices() && adj > ProcessList.PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ
                && (state.getLastTopTime() + mConstants.TOP_TO_FGS_GRACE_DURATION > now
                || state.getSetProcState() <= PROCESS_STATE_TOP)) {
            adj = ProcessList.PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ;
            state.setAdjType("fg-service-act");
            ...
        }        
```
当adj > 200的情况的前提下：
当存在前台service时，则adj=200, procState=PROCESS_STATE_FOREGROUND_SERVICE；
存在浮窗，则adj=200, procState=PROCESS_STATE_IMPORTANT_FOREGROUND；
前台应用切换为前台服务，adj=50,procState= PERCEPTIBLE_RECENT_FOREGROUND_APP_ADJ  //优先级暂时提高一部分


toast的情况
```
if (adj > ProcessList.PERCEPTIBLE_APP_ADJ
                || procState > PROCESS_STATE_TRANSIENT_BACKGROUND) {
            if (state.getForcingToImportant() != null) {
                // This is currently used for toasts...  they are not interactive, and
                // we don't want them to cause the app to become fully foreground (and
                // thus out of background check), so we yes the best background level we can.
                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                procState = PROCESS_STATE_TRANSIENT_BACKGROUND;
                state.setCached(false);
                state.setAdjType("force-imp");
                state.setAdjSource(state.getForcingToImportant());
               ...
            }
        }
```
toast的情况， adj = 200, procState = PROCESS_STATE_TRANSIENT_BACKGROUND


HeavyWeightProces情况
```
if (state.getCachedIsHeavyWeight()) {
            if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
                // We don't want to kill the current heavy-weight process.
                adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
                state.setCached(false);
                state.setAdjType("heavy");
                ...
            }
            if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
                procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
                state.setAdjType("heavy");
                ..
            }
        }
```
当进程为HeavyWeightProcess，则adj=400,procState为PROCESS_STATE_HEAVY_WEIGHT
可以通过查询adb shell dumpsys package | grep "cant_save_state"



``` 
  //更新
  private boolean updateAndTrimProcessLSP(final long now, final long nowElapsed,
            final long oldTime, final ActiveUids activeUids) {
        ArrayList<ProcessRecord> lruList = mProcessList.getLruProcessesLOSP();
        final int numLru = lruList.size();
        ...
        final int emptyProcessLimit = doKillExcessiveProcesses
                ? mConstants.CUR_MAX_EMPTY_PROCESSES : Integer.MAX_VALUE;
        final int cachedProcessLimit = doKillExcessiveProcesses
                ? (mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit) : Integer.MAX_VALUE;
        int lastCachedGroup = 0;
        int lastCachedGroupUid = 0;
        int numCached = 0;
        int numCachedExtraGroup = 0;
        int numEmpty = 0;
        int numTrimming = 0;

        for (int i = numLru - 1; i >= 0; i--) {
            ProcessRecord app = lruList.get(i);
            final ProcessStateRecord state = app.mState;
            if (!app.isKilledByAm() && app.getThread() != null) {
                // We don't need to apply the update for the process which didn't get computed
                if (state.getCompletedAdjSeq() == mAdjSeq) {
                    //应用adj
                    applyOomAdjLSP(app, true, now, nowElapsed);
                }

                final ProcessServiceRecord psr = app.mServices;
                //根据当前进程procState状态来决策
                switch (state.getCurProcState()) {
                    case PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        mNumCachedHiddenProcs++;
                        numCached++;
                        ...
                        // 当cached进程超过上限(cachedProcessLimit)，则杀掉该进程
                        if ((numCached - numCachedExtraGroup) > cachedProcessLimit) {
                            app.killLocked("cached #" + numCached,
                                    "too many cached",
                                    ApplicationExitInfo.REASON_OTHER,
                                    ApplicationExitInfo.SUBREASON_TOO_MANY_CACHED,
                                    true);
                        }
                        break;
                    case PROCESS_STATE_CACHED_EMPTY:
                    // 当空进程超过上限(CUR_TRIM_EMPTY_PROCESSES)，且空闲时间超过30分钟，则杀掉该进程
                    //oldTime为当前时间-最大空闲存活
                        if (numEmpty > mConstants.CUR_TRIM_EMPTY_PROCESSES
                                && app.getLastActivityTime() < oldTime) {
                            app.killLocked("empty for " + ((now
                                    - app.getLastActivityTime()) / 1000) + "s",
                                    "empty for too long",
                                    ApplicationExitInfo.REASON_OTHER,
                                    ApplicationExitInfo.SUBREASON_TRIM_EMPTY,
                                    true);
                        } else {
                        // 当空进程超过上限(emptyProcessLimit)，则杀掉该进程
                            numEmpty++;
                            if (numEmpty > emptyProcessLimit) {
                                app.killLocked("empty #" + numEmpty,
                                        "too many empty",
                                        ApplicationExitInfo.REASON_OTHER,
                                        ApplicationExitInfo.SUBREASON_TOO_MANY_EMPTY,
                                        true);
                            }
                        }
                        break;
                    default:
                        mNumNonCachedProcs++;
                        break;
                }

                if (app.isolated && psr.numberOfRunningServices() <= 0
                        && app.getIsolatedEntryPoint() == null) {
                   //没有services运行的孤立进程，则直接杀掉
                    app.killLocked("isolated not needed", ApplicationExitInfo.REASON_OTHER,
                            ApplicationExitInfo.SUBREASON_ISOLATED_NOT_NEEDED, true);
                } else {
                    // Keeping this process, update its uid.
                    updateAppUidRecLSP(app);
                }

                if (state.getCurProcState() >= ActivityManager.PROCESS_STATE_HOME
                        && !app.isKilledByAm()) {
                    numTrimming++;
                }
            }
        }
        //更新是否触发low momery   todo
        return mService.mAppProfiler.updateLowMemStateLSP(numCached, numEmpty, numTrimming);
    }          
```
