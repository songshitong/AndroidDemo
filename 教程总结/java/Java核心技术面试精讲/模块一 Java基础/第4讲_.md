



//了解引用前，要知道可达性分析，这样引用链就有了，用好WeakReference，就是分析引用链，在关键地方进行替换，在GC时就可以切断这条引用链了，
// 当然如果还有其他的引用的话，是不会进行对象回收的

公号-技术夜未眠
在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。
1 强引用
特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 
当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。
对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，
具体回收时机还是要看垃圾收集策略。

2 软引用
特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：
  即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，
  如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。
  如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

3 弱引用
弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不
  管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。
  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
应用场景：弱应用同样可用于内存敏感的缓存。

4 虚引用
特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，
做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，
把这个虚引用加入到与之关联的引用队列中。
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，
那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。


kursk.ye
于是我google到了这篇文章,http://www.kdgregory.com/index.php?page=java.refobj ，花了几天（真的是几天，不是几小时）才基本读完，
基本理解这几个reference的概念和作用，从这个角度来讲非常感谢作者，如果不是本文的介绍，我还以为GC还是按照reference counter的原理处理，
原来思路早变了。话说回来，《Java Reference Objects》真值得大家好好琢磨，相信可以回答很多人的问题，比如strong reference , 
soft reference , weak reference怎么互转，如果一个obj 已经 = null,就obj = reference.get()呗，再有，
文章中用weak reference 实现 canonicalizing map改善内存存储效率，减小存储空间的例子，真是非常经典啊。也希望作者以后照顾一下低层次读者，
写好技术铺垫和名词定义。顺便问一下大家是怎么留言的，在手机上打那么多字，还有排版是怎么处理的，我是先在电脑上打好字再COPY上来的，大
家和我一样吗？


书生依旧
回复 Miaozhe：
带有非空的 finalize() 方法的类会被 JVM 特殊处理：当 GC 发现这样的类的一个实例已经不再被任何活的强引用所引用时，
就会把它放入 finalizer queue，排队调用其 finalize() 方法。而当这样的一个实例的 fianlize() 方法被调用（并且该实例没有被复活）之后，
下一次 GC 就可以把它看作普通对象来清理掉了。

所以一个带 finalize() 方法的类的实例，从已经失去所有强引用到真正被GC回收，通常要经历两次GC。

所以，想让实现 finalize 的虚引用 enque 需要三行代码：
System.gc(); // 将虚引用加入 finalizer queue
System.runFinalization(); // 迫使虚应用的 finalize 执行
System.gc(); // GC 清除虚引用，enque
