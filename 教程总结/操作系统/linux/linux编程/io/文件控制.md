https://www.cnblogs.com/lonelycatcher/archive/2011/12/22/2297349.html
fcntl
linux 下fcntl的使用
功能描述：根据文件描述词来操作文件的特性。
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock *lock);
[描述]
fcntl()针对(文件)描述符提供控制。参数fd是被参数cmd操作(如下面的描述)的描述符。针对cmd的值，fcntl能够接受第三个参数int arg。

[返回值]
fcntl()的返回值与命令有关。如果出错，所有命令都返回－1，如果成功则返回某个其他值。下列三个命令有特定返回值：F_DUPFD ,
F_GETFD , F_GETFL以及F_GETOWN。
F_DUPFD   返回新的文件描述符
F_GETFD   返回相应标志
F_GETFL , F_GETOWN   返回一个正的进程ID或负的进程组ID

cntl函数有5种功能：
1. 复制一个现有的描述符(cmd=F_DUPFD).
2. 获得／设置文件描述符标记(cmd=F_GETFD或F_SETFD).
3. 获得／设置文件状态标记(cmd=F_GETFL或F_SETFL).
4. 获得／设置异步I/O所有权(cmd=F_GETOWN或F_SETOWN).
5. 获得／设置记录锁(cmd=F_GETLK , F_SETLK或F_SETLKW).


cmd值的F_GETFL和F_SETFL：   
F_GETFL    取得fd的文件状态标志，如同下面的描述一样(arg被忽略)，在说明open函数时，已说明了文件状态标志。不幸的是，
         三个存取方式标志 (O_RDONLY , O_WRONLY , 以及O_RDWR)并不各占1位。(这三种标志的值各是0 , 1和2，由于历史原因，
        这三种值互斥 — 一个文件只能有这三种值之一。) 因此首先必须用屏蔽字O_ACCMODE相与取得存取方式位，然后将结果与这三种值相比较。       
F_SETFL    设置给arg描述符状态标志，可以更改的几个标志是：O_APPEND，O_NONBLOCK，O_SYNC 和 O_ASYNC。而fcntl的文件状态标志
         总共有7个：O_RDONLY , O_WRONLY , O_RDWR , O_APPEND , O_NONBLOCK , O_SYNC和O_ASYNC

可更改的几个标志如下面的描述：
O_NONBLOCK   非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回-1和EAGAIN错误
O_APPEND     强制每次写(write)操作都添加在文件大的末尾，相当于open(2)的O_APPEND标志
O_DIRECT     最小化或去掉reading和writing的缓存影响。系统将企图避免缓存你的读或写的数据。如果不能够避免缓存，
           那么它将最小化已经被缓存了的数据造成的影响。如果这个标志用的不够好，将大大的降低性能
O_ASYNC      当I/O可用的时候，允许SIGIO信号发送到进程组，例如：当有数据可以读的时候

