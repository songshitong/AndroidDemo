上一节，我们讲了虚拟空间的布局。接下来，我们需要知道，如何将其映射成为物理地址呢？
你可能已经想到了，咱们前面讲 x86 CPU 的时候，讲过分段机制，咱们规划虚拟空间的时候，也是将空间分成多个段进行保存。
那就直接用分段机制呗。我们来看看分段机制的原理
趣谈Linux_分段机制.png

分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量。段选择子就保存在咱们前面讲过的段寄存器里面。段选择子里面最重要的是段号
，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间。如果段内偏移量是合法的，
就将段基地址加上段内偏移量得到物理内存地址
例如，我们将上面的虚拟空间分成以下 4 个段，用 0～3 来编号。每个段在段表中有一个项，在物理空间中，段的排列如下图的右边所示
趣谈Linux_虚拟内存与物理内存.png

如果要访问段 2 中偏移量 600 的虚拟地址，我们可以计算出物理地址为，段 2 基地址 2000 + 偏移量 600 = 2600。
多好的机制啊！
我们来看看 Linux 是如何使用这个机制的

在 Linux 里面，段表全称段描述符表（segment descriptors），放在全局描述符表 GDT（Global Descriptor Table）里面，
会有下面的宏来初始化段描述符表里面的表项
```
#define GDT_ENTRY_INIT(flags, base, limit) { { { \
    .a = ((limit) & 0xffff) | (((base) & 0xffff) << 16), \
    .b = (((base) & 0xff0000) >> 16) | (((flags) & 0xf0ff) << 8) | \
      ((limit) & 0xf0000) | ((base) & 0xff000000), \
  } } }
```

一个段表项由段基地址 base、段界限 limit，还有一些标识符组成。
```
DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
#ifdef CONFIG_X86_64
  [GDT_ENTRY_KERNEL32_CS]    = GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(0xc093, 0, 0xfffff),
  [GDT_ENTRY_DEFAULT_USER32_CS]  = GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),
  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),
  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),
#else
  [GDT_ENTRY_KERNEL_CS]    = GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),
  [GDT_ENTRY_KERNEL_DS]    = GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
  [GDT_ENTRY_DEFAULT_USER_CS]  = GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),
  [GDT_ENTRY_DEFAULT_USER_DS]  = GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),
......
#endif
} };
EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
```

这里面对于 64 位的和 32 位的，都定义了内核代码段、内核数据段、用户代码段和用户数据段。
另外，还会定义下面四个段选择子，指向上面的段描述符表项。这四个段选择子看着是不是有点眼熟？咱们讲内核初始化的时候，启动第一个用户态的进程，
就是将这四个值赋值给段寄存器
```
#define __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)
#define __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)
#define __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
#define __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)
```

通过分析，我们发现，所有的段的起始地址都是一样的，都是 0。这算哪门子分段嘛！所以，在 Linux 操作系统中，并没有使用到全部的分段功能。
那分段是不是完全没有用处呢？分段可以做权限审核，例如用户态 DPL 是 3，内核态 DPL 是 0。当用户态试图访问内核态的时候，会因为权限不足而报错

其实 Linux 倾向于另外一种从虚拟地址到物理地址的转换方式，称为分页（Paging）

对于物理内存，操作系统把它分成一块一块大小相同的页，这样更方便管理，例如有的内存页面长时间不用了，可以暂时写到硬盘上，称为换出
。一旦需要的时候，再加载进来，叫做换入。这样可以扩大可用物理内存的大小，提高物理内存的利用率。

这个换入和换出都是以页为单位的。页面的大小一般为 4KB。为了能够定位和访问每个页，需要有个页表，保存每个页的起始地址，再加上在页内的偏移量，
组成线性地址，就能对于内存中的每个位置进行访问了
趣谈Linux_页表.png

虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址

下面的图，举了一个简单的页表的例子，虚拟内存中的页通过页表映射为了物理内存中的页
趣谈Linux_虚拟内存与物理内存_页表映射.png

32 位环境下，虚拟地址空间共 4GB。如果分成 4KB 一个页，那就是 1M 个页。每个页表项需要 4 个字节来存储，
那么整个 4GB 空间的映射就需要 4MB 的内存来存储映射表。如果每个进程都有自己的映射表，100 个进程就需要 400MB 的内存。对于内核来讲，有点大了 
自己：4个字节表示32位 好像不对   //todo 看评论需要查看页表项的结构

页表中所有页表项必须提前建好，并且要求是连续的。如果不连续，就没有办法通过虚拟地址里面的页号找到对应的页表项了。

那怎么办呢？我们可以试着将页表再分页，4G 的空间需要 4M 的页表来存储映射。我们把这 4M 分成 1K（1024）个 4K，每个 4K 又能放在一页里面，
这样 1K 个 4K 就是 1K 个页，这 1K 个页也需要一个表进行管理，我们称为页目录表，这个页目录表里面有 1K 项，每项 4 个字节，页目录表大小也是 4K

页目录有 1K 项，用 10 位就可以表示访问页目录的哪一项。这一项其实对应的是一整页的页表项，也即 4K 的页表项。每个页表项也是 4 个字节，
因而一整页的页表项是 1K 个。再用 10 位就可以表示访问页表项的哪一项，页表项中的一项对应的就是一个页，是存放数据的页，这个页的大小是 4K，
用 12 位可以定位这个页内的任何一个位置

这样加起来正好 32 位，也就是用前 10 位定位到页目录表中的一项。将这一项对应的页表取出来共 1k 项，再用中间 10 位定位到页表中的一项，
将这一项对应的存放数据的页取出来，再用最后 12 位定位到页中的具体位置访问数据
趣谈Linux_页表目录项.png

你可能会问，如果这样的话，映射 4GB 地址空间就需要 4MB+4KB 的内存，这样不是更大了吗？ 当然如果页是满的，当时是更大了，
但是，我们往往不会为一个进程分配那么多内存。

比如说，上面图中，我们假设只给这个进程分配了一个数据页。如果只使用页表，也需要完整的 1M 个页表项共 4M 的内存，但是如果使用了页目录，
页目录需要 1K 个全部分配，占用内存 4K，但是里面只有一项使用了。到了页表项，只需要分配能够管理那个数据页的页表项页就可以了，也就是说，
最多 4K，这样内存就节省多了
当然对于 64 位的系统，两级肯定不够了，就变成了四级目录，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、
中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）
趣谈Linux_64位系统页目录项.png

总结时刻
这一节我们讲了分段机制、分页机制以及从虚拟地址到物理地址的映射方式。总结一下这两节，我们可以把内存管理系统精细化为下面三件事情
：第一，虚拟内存空间的管理，将虚拟内存分成大小相等的页；
第二，物理内存的管理，将物理内存分成大小相等的页；
第三，内存映射，将虚拟内存页和物理内存页映射起来，并且在内存紧张的时候可以换出到硬盘中
趣谈Linux_虚拟内存与物理内存总结.png

课堂练习
这一节我们说一个页的大小为 4K，有时候我们需要为应用配置大页（HugePage）。请你查一下大页的大小及配置方法，咱们后面会用到。


Leon📷
分页机制本质上来说就是类似于linux文件系统的目录管理一样，页目录项和页表项相当于根目录和上级目录，页内便宜量就是相对路径，绝对路径就是整个32位地址，分布式存储系统也是采用的类似的机制，先用元数据存储前面的路径，再用块内偏移定位到具体文件，感觉道理都差不多
作者回复: 是的

栋能
64位Linux机器，4KB页大小，那虚拟地址组成应该是：22位PGD、10位PUD、10位PMD、10位PTE、12位页偏移地址
作者回复: 由于x86_64处理器硬件限制。x86_64处理器地址线只有48条，故而导致硬件要求传入的地址48位到63位地址必须相同。 
4K页面下， 48位线性地址分为5段，位宽度分别是9、9、9、12。映射的方法为页表查找。
neohope
9、9、9、9、12，老师少打了一个9，：）

淤白
通过本篇内容，学习到在内存空间不足的情况下，使用索引可以有效的减少内存消耗，如果一层索引消耗还是无法接受，可以生成多级索引，除了第一层是提前创建，
其余索引通过懒加载的方式创建出来。

虚拟内存和物理内存中的管理，就是将内存空间划分成一个个大小相等的页，并对其做多级索引。在将虚拟内存和物理内存映射起来时，如果内存吃紧，
可以将部分内存页面换出到磁盘上

崔伟协
分页，分段机制的优劣在于哪儿呢，为什么有分页分段
作者回复: 都是硬件的机制，操作系统作为软件要用硬件机制。文章里面写了优劣势了。分段容易碎片，不容易换出。
万历十五年
关于分段和分页这部分推荐看陈莉君老师的linux内核讲解，非常清晰。分段是x86历史原因，分页为了更高效的使用更大物理内存。分段机制用于段地址到线性地址的转换，
分页机制用于线性地址到物理地址的转换。这其中，linux用了个巧妙的方法解决了intel x86对段机制的强制使用，即linux使段地址全是0，
此时把32位线性地址或48位线性地址经多级分页就映射到了物理地址

Helios
请问老师为什么一个表项用4个字节去存储呢
作者回复: 规定，可以去查一下表项的结构，太细节了，所以这里没有提
勿忘初心🍃
32位操作系统，高20位表示物理页号，低12位是各种FLAGS
Kevin⚡️Zhou
因为32位系统, 一个唯一的物理地址需要32个二进制位来识别, 4字节正好是32位, 表示内存中一个唯一的4kb空间的起始地址


garlic

处理器体系结构支持多重页面大小，操作系统可以根据需要进行相关设置，Linux可以通过hugepage，结合处理器支持页面大小设置多种页面大小，
相关笔记： https://garlicspace.com/2020/01/10/%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86-%e9%a1%b5%e9%9d%a2%e5%a4%a7%e5%b0%8f/
作者回复: 是的，Hugepage在优化内存的时候，经常使用，例如虚拟机或者DPDK使用Hugepage


k先生
老师，现在不都是用倒排页表了吗？还用多级页表吗？
作者回复: 本课程主要解析x86和x86_64

落石
64 位系统 2的64次方。四级页表，如果每级仍然以4K划分那就是 2^64 / 2^12 * 4 / 2^10 * 4 / 2^10 * 4 / 2^10 * 4 = 2^24，
即16M*4，64M每个进程？为什么没有采用位图的形式，记录页表索引。这样可以大量节约空间。
作者回复: 不会放满的。要都放满256T物理内存呀，哪儿弄这么多内存去。不能位图，又不是仅仅标识在不在，而是要映射地址的

Guarantee
老师，您专栏中的图，用的是什么软件，还是就是PS做的图吗？
作者回复: draw.io


配合看
https://mp.weixin.qq.com/s/HeqV8jZcVgI1hcJqXCpaRQ