进程与线程的区别总结
线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，
  它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。
根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位
资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，
  每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。
包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的
影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
//todo jvm的进程和线程的实现 https://blog.csdn.net/ThinkWon/article/details/102021274

https://harmonyos.51cto.com/posts/659
关于进程和线程，大家总是说的一句话是“进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元”。这句话理论上没问题，
我们来看看什么是所谓的“资源”呢。
什么是计算机资源
经典的冯诺依曼结构把计算机系统抽象成 CPU + 存储器 + IO，那么计算机资源无非就两种：
1. 计算资源
2. 存储资源
CPU是计算单元，单纯从CPU的角度来说它是一个黑盒，它只对输入的指令和数据进行计算，然后输出结果，它不负责管理计算哪些“指令和数据”。
   换句话说CPU只提供了计算能力，但是不负责分配计算资源。
```
计算资源是操作系统来分配的，也就是常说的操作系统的调度模块，由操作系统按照一定的规则来分配什么时候由谁来获得CPU的计算资源，比如分时间片
存储资源就是内存，磁盘这些存储设备的资源。操作系统使用了虚拟内存机制来管理存储器，从缓存原理的角度来说，把内存作为磁盘的缓存。进程是面向磁盘的，
 为什么这么说呢，进程表示一个运行的程序，程序的代码段，数据段这些都是存放在磁盘中的，在运行时加载到内存中。所以虚拟内存面向的是磁盘，
 虚拟页是对磁盘文件的分配，然后被缓存到物理内存的物理页中。
```
所以存储资源是操作系统由虚拟内存机制来管理和分配的。进程应该是操作系统分配存储资源的最小单元。

什么是进程
进程是对计算机的一种抽象
1. 进程表示一个逻辑控制流，就是一种计算过程，它造成一个假象，好像这个进程一直在独占CPU资源
2. 进程拥有一个独立的虚拟内存地址空间，它造成一个假象，好像这个进程一致在独占存储器资源

操作系统利用fork系统调用来创建一个子进程。fork所创建的子进程会复制父进程的虚拟地址空间。
要理解“复制”和“共享”的区别，复制的意思是会真正在物理内存复制一份内容，会真正消耗新的物理内存。共享的意思是使用指针指向同一个地址，
  不会真正的消耗物理内存。理解这两个概念的区别很重要，这是进程和线程的根本区别之一
那么有人问了如果我父进程占了1G的物理内存，那么fork会再使用1G的物理内存来复制吗，相当于一下用了2G的物理内存？
Copy on write优化
fork刚创建的子进程采用了共享的方式，只用指针指向了父进程的物理资源。当子进程真正要对某些物理资源写操作时，才会真正的复制一块物理资源来供子进程使用。
  这样就极大的优化了fork的性能，并且从逻辑来说子进程的确是拥有了独立的虚拟内存空间
fork不只是复制了页表结构，还复制了父进程的文件描述符表，信号控制表，进程信息，寄存器资源等等。它是一个较为深入的复制
从逻辑控制流的角度来说，fork创建的子进程开始执行的位置是fork函数返回的位置。这点和线程是不一样的，我们知道Java中的Thread需要写run方法，
 线程开始后会从run方法开始执行


既然我们知道了内核为进程维护了这么多资源，那么当内存进行进程调度时进行的进程上下文切换就容易理解了，一个进程运行要依赖这么些资源，
那么进程上下文切换就要把这些资源都保存起来写回到内存中，等下次这个进程被调度时再把这些资源再加载到寄存器和高速缓存硬件。
进程上下文切换保存的内容有：
1.页表 -- 对应虚拟内存资源
2.文件描述符表/打开文件表 -- 对应打开的文件资源
3.寄存器 -- 对应运行时数据
4.信号控制信息/进程运行信息


进程间通信    
虚拟内存机制为进程管理存储资源带来了种种好处，但是它也给进程带来了一些小麻烦，我们知道每个进程拥有独立的虚拟内存地址空间，
 看到一样的虚拟内地址空间视图，所以对不同的进程来说，一个相同的虚拟地址意味着不同的物理地址。我们知道CPU执行指令时采用了虚拟地址，
 对应一个特定的变量来说，它对应着一个特定的虚拟地址。这样带来的问题就是两个进程不能通过简单的共享变量的方式来进行进程间通信，
 也就是说进程不能通过直接共享内存的方式来进行进程间通信，只能采用信号，管道等方式来进行进程间通信。这样的效率肯定比直接共享内存的方式差

什么是线程
我们知道进程管理了一堆资源，并且每个进程还拥有独立的虚拟内存地址空间，会真正地拥有独立与父进程之外的物理内存。并且由于进程拥有独立的内存地址空间，
  导致了进程之间无法利用直接的内存映射进行进程间通信。
并发的本质是在时间上重叠的多个逻辑流，也就是说同时运行的多个逻辑流。并发编程要解决的一个很重要的问题就是对资源的并发访问的问题，
  也就是共享资源的问题。而两个进程恰恰很难在逻辑上表示共享资源。
线程解决的最大问题就是它可以很简单地表示共享资源的问题，这里说的资源指的是存储器资源，资源最后都会加载到物理内存，一个进程的所有线程
  都是共享这个进程的同一个虚拟地址空间的，也就是说从线程的角度来说，它们看到的物理资源都是一样的，这样就可以通过共享变量的方式来表示共享资源，
  也就是直接共享内存的方式解决了线程通信的问题。而线程也表示一个独立的逻辑流，这样就完美解决了进程的一个大难题

从存储资源的角度理解了线程之后，就不难理解计算资源的分配了。从计算资源的角度来说，对内核而言，进程和线程没有什么区别，所以
linux内核用内核调度实体(KSE)来表示一个调度的单元。

clone系统调用
在Linux系统中，线程是使用clone系统调用，clone是一个轻量级的fork，它提供了一系列的参数来表示线程可以共享父类的哪些资源，比如页表，
 打开文件表等等。我们上面说过了共享和复制的区别，共享只是简单地用指针指向同一个物理地址，不会在父进程之外开辟新的物理内存

Linux内核只提供了clone这个系统调用来创建类似线程的轻量级进程的概念。C语言利用了Pthreads库来真正创建了线程这个数据结构。
 Linux采用了1：1的模型，即C语言的Pthreads库创建的线程实体1：1对应着内核创建的一个KSE。Pthreads运行在用户空间，KSE运行在内核空间

既然线程共享了进程的资源，那么线程的上下文切换就好理解了。对操作系统来说，它看到要被调度进来的线程和刚运行的线程是同一个进程的，
  那么线程的上下文切换只需要保存线程的一些运行时的数据，比如线程的id、寄存器中的值、栈数据。而不需要像进程上下文切换那样要保存页表、文件描述符表、
  信号控制数据和进程信息等数据。页表是一个很重的资源，我们之前说过，如果采用一级页表的结构，那么32位机器的页表要达到4MB的物理空间。
  所以线程上下文切换是很轻量级的。

进程采用父子结构，init进程是最顶端的父进程，其他进程都是从init进程派生出来的。这样就很容易理解进程是如何共享内核的代码和数据的了。

而线程采用对等结构，即线程没有父子的概念，所有线程都属于同一个线程组，线程组的组号等于第一个线程的线程号


构建并发程序可以基于进程也可以线程
比如Nginx就是基于进程构建并发程序的。而Java天生只支持基于线程的方式来构建并发程序
JVM是C++/C写的，JVM本身利用了Pthreads库来创建操作系统的线程。JVM还要支持Java语言创建的线程的概念。
JVM提供了JavaThread类来对应Java语言的Thread，即Java语言中创建一个java.lang.Thread对象，JVM会相应的在JVM中创建一个JavaThread对象。
  同时JVM还创建了一个OSThread类来对应用Pthreads创建的底层操作系统的线程对象


进程VS 线程
1. 进程采用fork创建，线程采用clone创建
2. 进程fork创建的子进程的逻辑流位置在fork返回的位置，线程clone创建的KSE的逻辑流位置在clone调用传入的方法位置，
   比如Java的Thread的run方法位置
3. 进程拥有独立的虚拟内存地址空间和内核数据结构(页表，打开文件表等)，当子进程修改了虚拟页之后，会通过写时拷贝创建真正的物理页。
   线程共享进程的虚拟地址空间和内核数据结构，共享同样的物理页
4. 多个进程通信只能采用进程间通信的方式，比如信号，管道，而不能直接采用简单的共享内存方式，原因是每个进程维护独立的虚拟内存空间，
   所以每个进程的变量采用的虚拟地址是不同的。多个线程通信就很简单，直接采用共享内存的方式，因为不同线程共享一个虚拟内存地址空间，
   变量寻址采用同一个虚拟内存
5. 进程上下文切换需要切换页表等重量级资源，线程上下文切换只需要切换寄存器等轻量级数据
6. 进程的用户栈独享栈空间，线程的用户栈共享虚拟内存中的栈空间，没有进程高效
7. 一个应用程序可以有多个进程，执行多个程序代码，多个线程只能执行一个程序代码，共享进程的代码段
8. 进程采用父子结构，线程采用对等结构


https://labuladong.gitee.io/algo/4/33/141/
linux中进程和线程都用task_struct表示，从代码结构看区别不大
https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L723
```
struct task_struct {
	// 进程状态
	long			  state;
	// 虚拟内存结构体
	struct mm_struct  *mm;
	// 进程号
	pid_t			  pid;
	// 指向父进程的指针
	struct task_struct __rcu  *parent;
	// 子进程列表
	struct list_head		children;
	// 存放文件系统信息的指针
	struct fs_struct		*fs;
	// 一个数组，包含该进程打开的文件指针
	struct files_struct		*files;
};
```
用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，
  这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。
我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，
  就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。
你编译好的那个可执行程序只是一个文件，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，
  每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行
task_struct 就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常见的。
其中比较有意思的是 mm 指针和 files 指针。mm 指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；files 指针指向一个数组，
  这个数组里装着所有该进程打开的文件的指针
二、文件描述符是什么
先说 files，它是一个文件指针数组。一般来说，一个进程会从 files[0] 读取输入，将输出写入 files[1]，将错误信息写入 files[2]。
举个例子，以我们的角度 C 语言的 printf 函数是向命令行打印字符，但是从进程的角度来看，就是向 files[1] 写入数据；同理，
 scanf 函数就是进程试图从 files[0] 这个文件中读取数据。
每个进程被创建时，files 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引，
  所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。
我们可以重新画一幅图：
linux_文件描述符1.jpg
对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，
  我们的进程需要通过「系统调用」让内核进程访问硬件资源。
PS：不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。
如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到 files 的第 4 个位置：
linux_文件描述符2.jpg
明白了这个原理，输入重定向就很好理解了，程序想读取数据的时候就会去 files[0] 读取，所以我们只要把 files[0] 指向一个文件，
  那么程序就会从这个文件中读取数据，而不是从键盘：
```
command < file.txt
```
linux_文件描述符3.jpg
同理，输出重定向就是把 files[1] 指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：
```
command > file.txt
```
linux_文件描述符4.jpg
管道符其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：
```
cmd1 | cmd2 | cmd3
```
linux_文件描述符5.jpg
到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，
  统一装进一个简单的 files 数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效


线程是什么
首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。
为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。
我们知道系统调用 fork() 可以新建一个子进程，函数 pthread() 可以新建一个线程。但无论线程还是进程，都是用 task_struct 结构表示的，
  唯一的区别就是共享的数据区域不同。
换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享。就比如说，
  mm 结构和 files 结构在线程中都是共享的，我画两张图你就明白了


既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢？
因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，
 每个拷贝账户减少十元。
当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，
  线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度



