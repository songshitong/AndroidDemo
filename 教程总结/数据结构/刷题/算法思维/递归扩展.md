
https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&mid=100000222&idx=1&sn=2882975d5ed764368ba09d352a1c3c36&chksm=68f491e45f8318f2140d980c6b73b1318e3ef8be31194f4cf3bce054bfe93dc433dcb19be2a9#rd
大家都知道，一个方法自己调用自己就是递归，没错，但这只是对递归最表层的理解。

那么递归的实质是什么？
答：递归的实质是能够把一个大问题分解成比它小点的问题，然后我们拿到了小问题的解，就可以用小问题的解去构造大问题的解。

那小问题的解是如何得到的？
答：用再小一号的问题的解构造出来的，小到不能再小的时候就是到了零号问题的时候，也就是 base case 了。
算法_递归思路.png
那么总结一下递归的三个步骤：
Base case：就是递归的零号问题，也是递归的终点，走到最小的那个问题，能够直接给出结果，不必再往下走了，否则，就会成死循环；
拆解：每一层的问题都要比上一层的小，不断缩小问题的 size，才能从大到小到 base case；
组合：得到了小问题的解，还要知道如何才能构造出大问题的解。
所以每道递归题，我们按照这三个步骤来分析，把这三个问题搞清楚，代码就很容易写了
斐波那契数列
```
base case: f(0) = 0, f(1) = 1.
分解：f(n-1), f(n-2)
组合：f(n) = f(n-1) + f(n-2)
```
写出来的代码是：
```
class Solution {
    public int fib(int N) {
        if (N == 0) {
            return 0;
        } else if (N == 1) {
            return 1;
        }
        return fib(N-1) + fib(N-2);
    }
}
```
//todo  根据内容进行优化




https://www.cnblogs.com/liuzhen1995/p/6368429.html
递归的执行顺序    //todo 编译原理解释顺序
1 先执行递归，后进行回溯；    可以参考算法_递归思路.png
2 执行顺序满足栈的特性——先进后出     函数在编译器中由栈实现
斐波那契测试代码
```
public class Recursion {
    public int Fibonacci(int n){
        System.out.println(n+"分解");
        if(n == 1 || n == 2)
            return 1;
        System.out.println("********");
        int result = Fibonacci(n-1) + Fibonacci(n-2);
        System.out.println("result"+result);
        return result;
    } 
    public static void main(String[] args){
        Recursion temp = new Recursion();
        System.out.println("运行结果："+temp.Fibonacci(4));
    }
}
```
执行结果
```
4分解
********
3分解
********
2分解
1分解
result2
2分解
result3
运行结果：3
```
f(4)的分解过程
f(4)
f(3)   +    f(2)
f(2)+f(1)
第一次分解f(4)=f(3)+f(2),第二次分解f(3)=f(2)+f(1)，第三次f(2)=1,第四次f(1)=1 ,开始回溯f(3)=f(2)+f(1)=2 
第5次f(2)=1 回溯f(4)=f(3)+f(2)=2+1=3


