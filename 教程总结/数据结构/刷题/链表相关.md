链表遍历
遍历完成cur是最后一个，后续有操作不用判空，不遗漏异常情况  缺点，只有一个节点不进入while
```
Node cur = head;
while (cur.next != null) {
    cur = cur.next;
}
```
遍历完成cur=null ，后续有操作需要判空，容易出现空指针   
```
Node cur = head;
while (cur != null) {
    cur = cur.next;
}
```


向一个结点p后面插入newNode，直接把指针引用改变就可以了，根本不用遍历。。。
```
newNode.next=p.next;      //..=p.next 是对指针对应数据的访问
p.next = newNode;         //p.next=.. 是对指针对应数据的修改
```


https://segmentfault.com/a/1190000037518253   //todo corner case是啥
链表反转
迭代法三个指针   pre  cur  next  
链表反转_迭代法.png
递归解法    
base case:
当只有一个 node，或者没有 node 了呗，也就是
if(node == null || node.next == null) {
return node;
}
其实呢，只剩一个 node 的时候严格来讲并不是 base case，而是 corner case，
因为它本可以再 break down 到 node == null 的，但因为后面有对 node.next 的 dereference 操作，所以不能省略。
小问题   null->node1->node2  如何变为  null<-node1<-node2
这里很明显，在 2 后面接上 1 就行了，但是怎么拿到 2 呢？
别忘了，原问题里，此时还有 1 指向 2 呢～
也就是 node1.next = node2，
然后把 2 指向 1：node2.next = node1
合起来就是：node1.next.next = node1

