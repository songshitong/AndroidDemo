https://leetcode-cn.com/problems/partition-equal-subset-sum


https://labuladong.gitee.io/algo/3/25/81/
上篇文章 经典动态规划：0-1 背包问题 详解了通用的 0-1 背包问题，今天来看看背包问题的思想能够如何运用到其他算法题目。
而且，不是经常有读者问，怎么将二维动态规划压缩成一维动态规划吗？这就是状态压缩，很容易的，本文也会提及这种技巧。
读者在阅读本文之前务必读懂前文 经典动态规划：0-1 背包问题 中讲的套路，因为本文就是按照背包问题的解题模板来讲解的。

一、问题分析
先看一下题目：
给你一个 只包含正整数 的 非空 数组nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```
// 输入一个集合，返回是否能够分割成和相等的两个子集
bool canPartition(vector<int>& nums);
```

对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？
首先回忆一下背包问题大致的描述是什么：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，
  最多能装的价值是多少？

那么对于这个问题，我们可以先对集合求和，得出 sum，把问题转化为背包问题：
给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，下面我们就直接转换成背包问题，开始套前文讲过的背包问题框架即可



二、解法分析
第一步要明确两点，「状态」和「选择」。
这个前文 经典动态规划：背包问题 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

第二步要明确 dp 数组的定义。
按照背包问题的套路，可以给出如下定义：
dp[i][j] = x 表示，对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满。
比如说，如果 dp[4][9] = true，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。
  或者说对于本题，含义是对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。

根据这个定义，我们想求的最终答案就是 dp[N][sum/2]，base case 就是 dp[..][0] = true 和 dp[0][..] = false，因为背包没有空间的时候，
  就相当于装满了(true)，而当没有物品可选择的时候，肯定没办法装满背包(false)


第三步，根据「选择」，思考状态转移的逻辑。
回想刚才的 dp 数组含义，可以根据「选择」对 dp[i][j] 得到以下状态转移：
如果不把 nums[i] 算入子集，或者说你不把这第 i 个物品装入背包，那么是否能够恰好装满背包，取决于上一个状态 dp[i-1][j]，继承之前的结果。
如果把 nums[i] 算入子集，或者说你把这第 i 个物品装入了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。
  首先，由于 i 是从 1 开始的，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]，这一点不要搞混。
  dp[i - 1][j-nums[i-1]] 也很好理解：你如果装了第 i 个物品，就要看背包的剩余重量 j - nums[i-1] 限制下是否能够被恰好装满
  换句话说，如果 j - nums[i-1] 的重量可以被恰好装满(重量是j - nums[i-1])，那么只要把第 i 个物品装进去，也可恰好装满 j 的重量；否则的话，
    重量 j 肯定是装不满的。

最后一步，把伪码翻译成代码，处理一些边界情况。
以下是我的 C++ 代码，完全翻译了之前的思路，并处理了一些边界情况：
```
boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合    奇数的一般是小数，题目给定的数字是正整数，所以和为奇数，不可能凑出两个集合
    if (sum % 2 != 0) return false;
    int n = nums.length;
    sum = sum / 2;
    boolean[][] dp = new boolean[n + 1][sum + 1];  // 物品+1 ，背包容量+1
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = true;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {  //这个判断可以从 dp[i - 1][j - nums[i - 1]] 看出来
                // 背包容量不足，不能装入第 i 个物品  j<nums[i-1]
                dp[i][j] = dp[i - 1][j];   // 上面的值
            } else {
                // 装入或不装入背包      //上，左上的值       i从1开始，取物品为nums[i-1]
                //假如能恰好装满总的背包，那么最优解每一步都能状态当前的容量  ||只要存在一个种可能就可以装满当前， ||的结果为false，不存在这种可能
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[n][sum];
}
```

三、进行状态压缩
再进一步，是否可以优化这个代码呢？注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了。
所以，我们可以进行状态压缩，将二维 dp 数组压缩为一维，节约空间复杂度：
```
boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.length;
    sum = sum / 2;
    boolean[] dp = new boolean[sum + 1];
    
    // base case
    dp[0] = true;

    for (int i = 0; i < n; i++) {
        for (int j = sum; j >= 0; j--) {
            if (j - nums[i] >= 0) {
                //dp[j] = dp[j] 物品不放入背包， 相当于上值
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
    }
    return dp[sum];
}
```

其实这段代码和之前的解法思路完全相同，只在一行 dp 数组上操作，i 每进行一轮迭代，dp[j] 其实就相当于 dp[i-1][j]，所以只需要一维数组就够用了。
唯一需要注意的是 j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。
至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。
input [1,2,5]  Expected: false
正向遍历
```
i 1 j 0 dp[j] true     
i 1 j 1 dp[j] true     
i 1 j 2 dp[j] true
i 1 j 3 dp[j] true   dp[3] = dp[3] || dp[3-nums[1]]= dp[3] || dp[2]
i 1 j 4 dp[j] true   dp[4] = dp[4] || dp[4-nums[1]] = dp[4] || dp[3]   dp[3]已经初始化了，dp[3]被放入了两次
i 2 j 0 dp[j] true
i 2 j 1 dp[j] true
i 2 j 2 dp[j] true
i 2 j 3 dp[j] true
i 2 j 4 dp[j] true
i 3 j 0 dp[j] true
i 3 j 1 dp[j] true
i 3 j 2 dp[j] true
i 3 j 3 dp[j] true
i 3 j 4 dp[j] true
```
反向遍历
```
i 1 j 4 dp[j] false  dp[4] = dp[4] || dp[4-nums[1]] = dp[4] || dp[3]  dp[3]还未初始化
i 1 j 3 dp[j] false  dp[3] = dp[3] || dp[3-nums[1]]= dp[3] || dp[2]   dp[3]初始化了，第一次被放入
i 1 j 2 dp[j] false
i 1 j 1 dp[j] true
i 1 j 0 dp[j] true
i 2 j 4 dp[j] false
i 2 j 3 dp[j] true
i 2 j 2 dp[j] true
i 2 j 1 dp[j] true
i 2 j 0 dp[j] true
i 3 j 4 dp[j] false
i 3 j 3 dp[j] true
i 3 j 2 dp[j] true
i 3 j 1 dp[j] true
i 3 j 0 dp[j] true
```
dp[j] = dp[j] || dp[j - nums[i]];  的代码逻辑是在一维数组上面根据前面的值和当前求或，然后覆盖当前   正向遍历会出现一个物品使用多次，遍历顺序影响结果
 二维数组上是不同状态的组合，不会发生覆盖，所以遍历顺序不影响结果


https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E6%80%BB%E7%BB%93
倒叙遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！
举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15
如果正序遍历
dp[1] = dp[1 - weight[0]] + value[0] =dp[0]+value[0]= 15
dp[2] = dp[2 - weight[0]] + value[0] =dp[1]+value[0]=dp[0]+value[0]+value[0] =  30     
此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？
倒叙就是先算dp[2]
dp[2] = dp[2 - weight[0]] + value[0] =dp[1]+value[0] = 15 （dp数组已经都初始化为0）
dp[1] = dp[1 - weight[0]] + value[0] = dp[0]+ value[0] = 15
所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

那么问题又来了，为什么二维dp数组历的时候不用倒叙呢？
因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！