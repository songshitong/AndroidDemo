https://zhuanlan.zhihu.com/p/77415657

软件系统中耦合的对象
软件中的对象就像齿轮一样，协同工作，但是互相耦合，一个零件不能正常工作，整个系统就崩溃了。这是一个强耦合的系统。齿轮组中齿轮之间的啮合关系,
与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。
现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，
 架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形
//B{A a = new A()}  这样B建立了对A的强关联，后期A的变动，必然影响到B，并且对于B来说，A是不可替代的


控制反转（Inversion of Control）是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：
  借助于“第三方”实现具有依赖关系的对象之间的解耦，中间位置的“第三方”，也就是IOC容器

软件系统在没有引入IOC容器之前，对象B依赖于对象A，那么对象B在初始化或者运行到某一点的时候，自己必须主动去创建对象A或者使用已经创建的对象A。
  无论是创建还是使用对象B，控制权都在自己手上

软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象B运行到需要对象A的时候，
  IOC容器会主动创建一个对象A注入到对象B需要的地方。

通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来



依赖倒置原则（Dependency Inversion Principle ）
假设我们设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：
汽车依赖车身，车身依赖底盘，底盘依赖轮子。
轮子<-底盘<-车身<-汽车
这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。
这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，
那么车身也得改，同理汽车设计也得改——整个设计几乎都得改！

我们现在换一种思路。我们先设计汽车的大概样子，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，
依赖关系就倒置过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。
汽车<-底盘<-底盘<-汽轮子
这时候，上司再说要改动轮子的设计，我们就只需要改动轮子的设计，而不需要动底盘，车身，汽车的设计了

这就是依赖倒置原则——把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑。高层建筑决定需要什么，底层去实现这样的需求，
但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况


控制反转（Inversion of Control）就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）

这几个之间的关系
依赖倒置原则的思路是 控制反转，控制反转的方法是依赖注入   其中控制反转用到了ioc容器



耦合的代码     
```
Car{
  private framework;
  Car(){
     framework = new FrameWork;
  }
  run(){ ... }
}

Framework{
  private bottom;
  Framework(){
     bottom = new Bottom();
  }
}

Bottom{
  private tire;
  Bottom(){
    tire = new Tire();
  }
}

Tire{
  private size;
  Tire(){
    size=30;
  }
}
```
汽车的使用 是 (new Car()).run()

这段代码就是上层建筑依赖下层建筑
  每一个类的构造函数都直接调用了底层代码的构造函数。假设我们需要改动一下轮胎（Tire）类，把它的尺寸变成动态的，而不是一直都是30
  需要修改每一个类的结构
```
Car{
  private framework;
  Car(int size){
     framework = new FrameWork(size);
  }
  run(){ ... }
}

Framework{
  private bottom;
  Framework(int size){
     bottom = new Bottom(szie);
  }
}

Bottom{
  private tire;
  Bottom(int size){
    tire = new Tire(size);
  }
}

Tire{
  private size;
  Tire(s){
    size=s;
  }
}
```
仅仅是为了修改轮胎的构造函数，这种设计却需要修改整个上层所有类的构造函数！在软件工程中，这样的设计几乎是不可维护的——在实际工程项目中，
有的类可能会是几千个类的底层，如果每次修改这个类，我们都要修改所有以它作为依赖的类，那软件的维护成本就太高了。


依赖注入方式
我们需要进行控制反转（IoC），及上层控制下层，而不是下层控制着上层。我们用依赖注入（Dependency Injection）这种方式来实现控制反转。
所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”
```
Car{
  private framework;
  Car(Framework fw){
     framework = fw;
  }
  run(){ ... }
}

Framework{
  private bottom;
  Framework(Bottom bt){
     bottom = bt;
  }
}

Bottom{
  private tire;
  Bottom(Tire t){
    tire = t;
  }
}

Tire{
  private size;
  Tire(){
    size=30;
  }
}
```
这时候使用方法进行了改变      这段代码对于Car来说就是ioc容器，从容器获取需要依赖的对象
Tire tire = new Tire();
Bottom bottom = new Bottom(tire);
Framework framework = new Framework(bottom);
Car car = new Car(framework);
car.run();

上面代码变成了上层需要什么，下层实现什么，下层依赖上层，也就是依赖倒置
如果要动态的修改Tire，现在只需修改Tire类就可以了，不用修改其他任何上层类


在实际的工程中，这种设计模式还有利于不同组的协同合作和单元测试：比如开发这四个类的分别是四个不同的组，那么只要定义好了接口，
四个不同的组可以同时进行开发而不相互受限制；而对于单元测试，如果我们要写Car类的单元测试，就只需要Mock一下Framework类传入Car就行了，
而不用把Framework, Bottom, Tire全部new一遍再来构造Car

依赖注入除了构造器参数传入还有另外两种方法：Setter传递和接口传递  原理差不多


ioc容器的好处
因为采用了依赖注入，在初始化的过程中就不可避免的会写大量的new。这里IoC容器就解决了这个问题。这个容器可以自动对你的代码进行初始化，
你只需要维护一个Configuration（可以是xml可以是一段代码或者注解之类的），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码。
这是引入IoC Container的第一个好处
IoC Container的第二个好处是：我们在创建实例的时候不需要了解其中的细节
  在上面的例子中，我们自己手动创建一个车instance时候，是从底层往上层new的
  我要创建一个car的实例->new Tire()->注入->new Bottom() -> 注入 -> new Framework() -> 注入 ->new Car()
  这个过程中，我们需要了解整个Car/Framework/Bottom/Tire类构造函数是怎么定义的，才能一步一步new/注入

而IoC Container在进行这个工作的时候是反过来的，它先从最上层开始往下找依赖关系，到达最底层之后再往上一步一步new（有点像深度优先遍历）
 我要创建一个car的实例->查询依赖 -> Car需要Framework -> 查询依赖 -> Framework需要Bottom -> 查询依赖 -> Bottom需要Tire ->查询依赖-> 到底了,
  开始创建->new Tire()->注入->new Bottom() -> 注入 -> new Framework() -> 注入 ->new Car()

这里IoC Container可以直接隐藏具体的创建实例的细节，在我们来看它就像一个工厂：
 我要创建一个car的实例-> ioc容器 -> Car的实例
我们只需要向工厂请求一个Car实例，然后它就给我们按照Config创建了一个Car实例。我们完全不用管这个Car实例是怎么一步一步被创建出来

实际项目中，有的Service Class可能是十年前写的，有几百个类作为它的底层。假设我们新写的一个API需要实例化这个Service，
  我们总不可能回头去搞清楚这几百个类的构造函数吧？
 IoC Container的这个特性就很完美的解决了这类问题——因为这个架构要求你在写class的时候需要写相应的Config文件，
 所以你要初始化很久以前的Service类的时候，前人都已经写好了Config文件，你直接在需要用的地方注入这个Service就可以了。
 这大大增加了项目的可维护性且降低了开发难度


总结
1 控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，
   在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。
2 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。
3 通过IoC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。