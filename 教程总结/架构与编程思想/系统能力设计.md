
系统设计能力  日志设计，图片框架设计

2022-06-25
多账号系统
账号存在退出登录，缓存的数据，
1 文件是否跟用户绑定，是否用户共用
2 退出登录清空哪些内容，保留哪些内容


并行转串行  
转为串行之后，一种一个命令过长，其他的阻塞了怎么办，要执行放行吗？接收端能否支持多个命令呢  如果只对命令过长的串行化处理呢
每个命令之间是否设置间隔(接收端不能连续接受。。。)
对于存在命令过长，是否可以让这种命令单独一个队列，短命令一个队列，同时写或读，接受端是否支持，又如何区分命令呢
1. 基于回调，手写一个回调完执行下一个
https://github.com/dingjikerbo/Android-BluetoothKit/blob/aec658be16fc2c9c2d3188435427235ec4f66dc3/library/src/main/java/com/inuker/bluetooth/library/connect/BleConnectDispatcher.java
```
public class BleConnectDispatcher {
    private List<BleRequest> mBleWorkList = new LinkedList<BleRequest>();
    public void notify(UUID service, UUID character, BleGeneralResponse response) {
        addNewRequest(new BleNotifyRequest(service, character, response));
    }
    private void addNewRequest(BleRequest request) {
        if (mBleWorkList.size() < MAX_REQUEST_COUNT) {
            request.setRuntimeChecker(this);
            request.setAddress(mAddress);
            request.setWorker(mWorker);
            mBleWorkList.add(request);
        } else {
            request.onResponse(Code.REQUEST_OVERFLOW);
        }
        scheduleNextRequest(10);
    }
    @Override
    public void onRequestCompleted(BleRequest request) {
        //请求完成回调，开始处理下一个
        mCurrentRequest = null;
        scheduleNextRequest(10);
    }
    private void scheduleNextRequest(long delayInMillis) {
        mHandler.sendEmptyMessageDelayed(MSG_SCHEDULE_NEXT, delayInMillis);
    }
    private void scheduleNextRequest() {
        if (!ListUtils.isEmpty(mBleWorkList)) {
            mCurrentRequest = mBleWorkList.remove(0);
            //对处理增加回调监听
            mCurrentRequest.process(this);
        }
    }
}
```
缺点：这种串行，如果一个请求没有回调，后续的请求也没法进行下一个了   解决定时器，超时没回复进行下一个(tcp的超时重传)
     将没有回复的串行改为并行，这样就不等着了
2. 放入队列，链表，数组arraylist等
3. 串行线程池  