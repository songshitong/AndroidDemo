https://juejin.cn/post/6844904079152381959#heading-4

基本类型
java基本类型    
只有8种基本类型可以算.其他引用类型都是由java虚拟机决定的自己不能操作
六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型
表示范围公式：(-2的n-1次方) 至 （2的n-1次方 - 1），
因为第一位用于当做符号位，第1个bit表示符号,0表示正数,1表示负数
基本类型	占的内存（1字节是8位）	表示范围
byte	1字节	-128至127：-2的7次方至2的7次方-1           byte a = 100
short	2字节	-32768至32767：-2的15次方至2的15次方-1     short s = 1000
int	    4字节	-2147483648 至 2147483647 ：-2的31次方至2的31次方-1   int a = 100000
long	8字节	-2的63次方至2的63次方-1                    long a = 100000L
float	4字节	有效小数位6-7位                            float f1 = 234.5f
double	8字节	有效小数位15位                             double   d1  = 7D
char	2字节                                             char letter = 'A'
boolean	1字节                                             boolean one = true

引用类型
String长度限制
https://mp.weixin.qq.com/s/mv7jC-oV2nNfMf46gCsvCw   todo


https://juejin.cn/post/6844904079152381959#heading-23
Java的char是两个字节，是怎么存Utf-8的字符的？  //todo

面向对象编程
面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，
   一个对象包含了数据和操作数据的函数

https://zhuanlan.zhihu.com/p/34586522   
封装、继承、多态   三大特性
封装：把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。
封装的优点：
1.隐藏实现细节。
2.安全性。
比如你在程序中私有化了age属性，并提供了对外的get和set方法，当外界 使用set方法为属性设值的时候 你可以在set方法里面做个if判断，
  把值设值在0-80岁，那样他就不能随意赋值了。
3.增加代码复用性。
比如在工具中封装的各种方法，可以任意调用，而不用每处去实现细节。
4。模块化。
封装分为封装属性，方法，类等等。有利于代码调试，相互配合。

继承的概念：从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。
继承的好处：
1.继承是传递的，易于在其基础上构造和扩充。
2.简化对事物的描绘，使得层次更加清晰。
3.减少代码冗余。
4.提高可维护性。


多态
多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果。
多态的三个必要条件：
继承父类。
重写父类的方法。
父类的引用指向子类对象。

//有的会把抽象作为第四特性
抽象的概念：通过特定的实例抽取出共同的特征行成概念的过程。
抽象方法：
被abstract修饰的方法是抽象方法。抽象方法没有方法体。修饰符返回类型为 函数名（）；抽象方法的修饰只能用public或protected或者没有修饰。
不能被final，static，private修饰。


什么是多态
面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。
多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）
实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
多态的作用：消除类型之间的耦合关系。
现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
  如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果
多态的好处：
1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。
  实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。
Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。



接口的意义？
规范、扩展、回调

抽象类的意义？
为子类提供一个公共的类型，封装子类中的重复内容，定义抽象方法，子类虽然有不同的实现，但是定义是一致的

抽象类和接口区别？
共同点
1、是上层的抽象层，都不能被实例化。
2、都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不提供具体的实现。
区别
1、子类使用extends关键字来继承抽象类，如果子类不是抽象类的话，它需要提供抽象类中所有声明方法的实现。子类使用关键字implements来实现接口，
它需要提供接口中所有声明方法的实现。
2、抽象类可以有默认的方法实现，接口根本不存在方法的实现。（1.8 default关键字可声明）
3、多继承：一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类，但是一个类可以实现多个接口。
4、构造器：抽象类可以有构造器，接口不能有构造器。
5、和普通Java类的区别：除了你不能实例化抽象类之外，抽象类和普通Java类没有任何区别，而接口则是完全不同的类型。
6、访问修饰符：抽象方法可以有public、protected和default修饰符，接口方法默认修饰符是public，你不可以使用其它修饰符。
7、main方法：抽象方法可以有main方法并且我们可以运行它，而接口没有main方法，因此我们不能运行它。
8、速度：抽象类比接口速度要快，接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。


https://mp.weixin.qq.com/s?__biz=MzkxMzMyMzgyMw==&mid=2247489481&idx=1&sn=4ff6ba798eca4f06bbfd9467fcb65a88&source=41#wechat_redirect
什么是内部类？内部类的作用？
1、内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
3、创建内部类对象并不依赖于外围类对象的创建。
4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。

静态内部类、非静态内部类的理解？
静态内部类：只是为了降低包的深度，方便类的使用，静态内部类适用于包含在类当中，但又不依赖于外在的类，不用使用外在类的非静态属性和方法，
  只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类对象的引用。
非静态内部类：持有外部类的引用，可以自由使用外部类的所有变量和方法

静态内部类的设计意图？
静态内部类与非静态内部类之间存在一个最大的区别：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，
 但是静态内部类却没有。
//持有外部的引用从而访问外部的变量
而没有这个引用就意味着：
  它的创建是不需要依赖于外部类的。
  它不能使用任何外部类的非静态成员变量和方法。


静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
结论
java中静态属性和静态方法、非静态的属性可以被继承，但是不可以被重写而是被隐藏。
原因
1）、静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成，不需要继承机制即可以调用。如果子类里面定义了静态方法和属性，
  那么这时候父类的静态方法或属性称之为隐藏。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，
  至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在隐藏的这种情况。
2）、有了继承和重写就可以实现父类的引用指向不同子类的对象，重写后子类的优先级要高于父类的优先级，但是隐藏是没有这个优先级之分的。
3）、 静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。
   非静态方法可以被继承和重写，因此可以实现多态


为什么Java里的匿名内部类只能访问final修饰的外部变量？
因为匿名内部类最终会编译成一个单独的类，而被该类使用的变量会以构造函数参数的形式传递给该类，例如：Integer a，
如果变量不定义成final的，变量a在匿名内部类便可以被修改，进而造成和外部的变量a不一致的问题，为了避免这种不一致的情况，
因此Java规定匿名内部类只能访问final修饰的外部变量。
//字节码 可以看到匿名内部类持有外部的引用


Java 的匿名内部类有哪些限制？
1、没有人类认知意义上的名字，包名.OuterClass$
表示定位的第一个匿名内部类，外部类加 N，N是匿名内部类的顺序
2、Java中的匿名内部类不可以继承，只有内部类才可以有实现继承、实现接口的特性。而Kotlin中的匿名内部类是支持继承的，
  如：val runnableFoo = object: Foo(), Runnable { override fun run() { } }
3、只能捕获外部作用域内的final变量
4、创建时只有单一方法的接口可以用Lambda转换
5、如果定义在非静态作用域内，匿名内部类会默认持有外部类的引用，可能会导致内存泄漏。


Object相关
java中==和equals区别
默认情况下也就是从超类Object继承而来的equals方法与‘==’是完全等价的，比较的都是对象的内存地址，但我们可以重写equals方法，
使其按照我们需求的方式进行比较，如String类重写了equals方法，使其比较的是字符的序列，而不再是内存地址
在java集合中，判断两个对象是否相等的规则是：
1）、判断两个对象的hashCode是否相等。
2）、判断两个对象用equals运算是否相等。


为什么复写equals方法的同时需要复写hashcode方法，前者相同后者是否相同，反过来呢？为什么？
要考虑到类似HashMap、HashTable、HashSet的这种散列的数据类型的运用，当我们重写equals时，是为了用自身的方式去判断两个自定义对象是否相等，
然而如果此时刚好需要我们用自定义的对象去充当hashmap的键值使用时，就会出现我们认为的同一对象，却因为hash值不同而导致hashmap中存了两个对象，
从而才需要进行hashcode方法的覆盖


hashcode()和 equals()的作用、区别、联系？
因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（这是生成hash值的公式可能存在的问题），
所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：
1、equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
2、hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。


反射相关
反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力
反射机制直接创建对象即使这个对象在编译期是未知的，
反射的核心：是 JVM 在运行时 才动态加载的类或调用方法或属性，他不需要事先（写代码的时候或编译期）知道运行对象是谁
使用 Java 反射机制可以在运行时期检查 Java 类的信息，检查 Java 类的信息往往是你在使用 Java 反射机制的时候所做的第一件事情
获取class的方式
```
1  直接获取某一个类的 class   Class strClass = String.class;
2 使用 Class 类的 forName 静态方法  Class.forName("sst.example.lib.reflect.ReflectTest")
3 调用某个对象的 getClass() 方法  String str1=str1.getClass()
```
反射方法的其它使用--通过反射越过泛型检查


https://juejin.cn/post/6844904079152381959#heading-23
java中的泛型，泛型擦除以及相关的概念，解析与分派
泛型是Java SE1.5的新特性，泛型的本质是参数化类型，也就是说所操的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，
分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单，避免类型强转出现异常
另一个好处提高代码的可重用性

在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，
而这种转换是要求开发者实际参数类型可以预知的情况下进行的。对于强制类型换错误的情况，编译器可能不提示错误，在运行的时候出现异常，
这是一个安全隐患。

泛型的好处是在编译的时候检查类型安全，并且所有的转换都是自动和隐式的，提高代码的重用率。
1、泛型的类型参数只能是类类型（包括自定义类），不是简单类型。
2、同一种泛型可以对应多个版本（因为参数类型是不确的），不同版本的泛型类实例是不兼容的。
3、泛型的类型参数可以有多个。 <K,V>
4、泛型的参数类型可以使用extends语句表示上界，super表示下界。习惯上称为“有界类型”
5、泛型的参数类型还可以是通配符类型。例如Class<?> classType = Class.forName("java.lang.String");


泛型擦除以及相关的概念
泛型信息只存在代码编译阶段，在进入JVM之前，与泛型关的信息都会被擦除掉。  
在类型擦除的时候，如果泛型类里的类型参数没有指定上限，则会被转成Object类型，如果指定了上限，则会被传转换成对应的类型上限。
擦除规则
```
<T> 擦除后变为 Object
<T extends A> 擦除后变为 A
<? extends A> 擦除后变为 A
<? super A> 擦除后变为Object
```

Java中的泛型基本上都是在编译器这个层次来实现的。生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，
  会在编译器在编译的时候擦除掉。这个过程就称为类型擦除。
类型擦除引起的问题及解决方法：
1、先检查，在编译，以及检查编译的对象和引用传递的问题
2、自动类型转换
3、类型擦除与多态的冲突和解决方法
4、泛型类型变量不能是基本数据类型
5、运行时类型查询
6、异常中使用泛型的问题
7、数组（这个不属于类型擦除引起的问题）
9、类型擦除后的冲突
10、泛型在静态方法和静态类中的问题
todo https://www.cnblogs.com/wuqinglong/p/9456193.html#:~:text=%E4%B8%89%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%201%E3%80%81%E5%85%88%E6%A3%80%E6%9F%A5%E5%86%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98,2%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%203%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%B8%8E%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%B2%E7%AA%81%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95



如何获取泛型  以泛型方法返回类型为例
```
1. 反射获取Method
2. method.getGenericReturnType
3. 如果是ParameterizedType，获取getActualTypeArguments()即可
```
泛型不是在编译的时候被擦除了吗？为啥在运行时还能够获取到具体的泛型类型？
//https://juejin.cn/post/6950042154496425992
泛型中所谓的类型擦除，其实只是擦除 Code 属性中的泛型信息，在类常量池属性（Signature 属性、LocalVariableTypeTable 属性）
中其实还保留着泛型信息，而类常量池中的属性可以被 class 文件，字段表，方法表等携带，这就使得我们声明的泛型信息得以保留，
这也是我们在运行时可以反射获取泛型信息的根本依据




说说你对Java注解的理解？  //提示作用，例如@Deprecated
注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记。程序可以利用ava的反射机制来了解你的类及各种元素上有无何种标记，
针对不同的标记，就去做相应的事件。标记可以加在包，类，字段，方法，方法的参数以及局部变量上


final，finally，finalize
final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，
而 final 的方法也是不可以重写的（override）。
finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、
保证 unlock 锁等动作。
finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。
finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。

异常
Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），
它是异常处理机制的基本组成类型
Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。
Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。
//StackOverflowError,OutOfMemoryError->VirtualMachineError->Error    名字带error

Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
//非RuntimeException的子类都是checked异常   IOException->Exception

不检查异常就是所谓的运行时异常，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求
NullPointerException，ArrayIndexOutOfBoundsException  ->RuntimeException->Exception   名字带exception

异常捕获注意点
第一，尽量不要捕获类似 Exception 这样的通用异常，而是应该捕获特定异常
第二，不要生吞（swallow）异常。这是异常处理中要特别注意的事情，因为很可能会导致非常难以诊断的诡异情况

引用相关
Java中根据其生命周期的长短，将引用分为4类。
1 强引用
  只要存在引用就不进行回收
2 软引用
  发生OOM或内存不足时回收
3 弱引用
  发生Gc时进行回收，回收后的对象进入ReferenceQueue
4 虚引用
幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制  检测对象是否进行回收