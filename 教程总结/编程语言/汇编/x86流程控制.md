https://zhuanlan.zhihu.com/p/23845369

CPU中的顺序执行过程
CPU里有一个寄存器专门存放“程序执行到哪里了”这样一个信息，而且这么做也是说得过去的，那就是：必须有一个东西记录当前程序执行到的位置，
否则CPU执行完一条指令之后，就不知道接下来该干什么了。

在x86体系结构的CPU里面，这个执行位置的信息，是保存在叫做eip的寄存器中的。不过很遗憾，这个寄存器比较特殊，无法通过mov指令进行修改，
也就是说，这么写mov eip, 0x233是行不通的。

在执行一条指令的时候，eip此时代表的是下一条指令的位置，eip里保存的就是下一条指令在内存中的地址。这样，CPU在执行完成一条指令之后，
就直接根据eip的值，取出下一条指令，同时还要修改eip，往eip上加一个指令的长度，让它继续指向后一条指令。

有了这样一个过程，CPU就能自动地去从前往后执行每一条指令了。而且，上述过程是在CPU中自动发生的，你写代码的时候根本不需要关心这个东西，
只需要按照自己的思路从前往后写就是了

//为什么不可以修改地址
大多数CPU设计指令集的时候都不会允许直接对PC进行修改，如果这样，机器会很不安全（等于有了随时随地可以确定任意执行位置的机制，太疯狂了！），
要改变PC位置，只能通过调用，如Call，ret，或者跳转jmp和Jxx，或者Loop、int的逻辑改变，这样程序指向点的转移至少是有逻辑控制的，安全些！

跳转指令
达到更改eip的效果
jmp  等价C的goto
通常配合cmp比较指令使用
```
ja 大于时跳转
jae 大于等于
jb 小于
jbe 小于等于
je 相等
jna 不大于
jnae 不大于或者等于
jnb 不小于
jnbe 不小于或等于
jne 不等于
jg 大于(有符号)
jge 大于等于(有符号)
jl 小于(有符号)
jle 小于等于(有符号)
jng 不大于(有符号)
jnge 不大于等于(有符号)
jnl 不小于
jnle 不小于等于
jns 无符号
jnz 非零
js 如果带符号
jz 如果为零
```
j后面字母的意思  例如jne就是not equal不等于  jle是lower equal小于等于
```
a: above
e: equal
b: below
n: not
g: greater
l: lower
s: signed
z: zero
```
代码举例
```
int main() {
    register int x = 10;
    if ( x > 100 ) {
        x = x - 20;
    }else{
       x= x+20;
    }
    return 0;
}
```
register关键字，是请求这个变量在编译后尽可能用寄存器来进行表示，方便我们进行分析，去掉后可能是存入地址而不是寄存器
查看汇编代码
```
Dump of assembler code for function main:
   0x0000000000401102 <+0>:     push   %rbp
   0x0000000000401103 <+1>:     mov    %rsp,%rbp
   0x0000000000401106 <+4>:     push   %rbx
   0x0000000000401107 <+5>:     mov    $0xa,%ebx
   0x000000000040110c <+10>:    cmp    $0x64,%ebx
   0x000000000040110f <+13>:    jle    0x401116 <main+20>
   0x0000000000401111 <+15>:    sub    $0x14,%ebx
   0x0000000000401114 <+18>:    jmp    0x401119 <main+23>
   0x0000000000401116 <+20>:    add    $0x14,%ebx
   0x0000000000401119 <+23>:    mov    $0x0,%eax
   //按q退出时打印
   0x000000000040111e <+28>:    pop    %rbx
   0x000000000040111f <+29>:    pop    %rbp
   0x0000000000401120 <+30>:    retq    
```
C语言和汇编语言中的条件判断，其组织的思路是刚好相反的
C语言中：x大于100的时候，进入if块中执行减法
汇编语言中：0x64小于等于100的时候，跳过中间的减法   jle 0x401119 <main+23> 跳到addl执行加法

if都有了，那else if和else怎么办呢
理一下思路：
1 首先根据你的需要，画出整个程序的流程图
2 按照流程图中的跳转关系，通过汇编表达出来
也就是说，在汇编里面，实际上没有所谓的if或else的说法，只是前面为方便说明，使用了C语言作类比，实际上汇编还可以写得比C语言的判断更加灵活。
事实上，C语言里面的几种常见的if组织结构，都有对应的汇编语言里的套路。说白了，都是套路。
那你怎么才能知道这些套路呢？很简单，用C语言写一个简单的程序，编译后按之前文章所说的内容，使用gdb去反汇编然后就能知道这里面的具体做法了。

状态寄存器
在汇编语言里面实现“先比较，后跳转”的功能时，后面的跳转指令是怎么利用前面的比较结果的呢
在此之前，先想一下，如果自己在脑子里思考同样的逻辑，是怎么样的？
先比较两个数
记住比较结果
根据比较结果作出决定
CPU里面也有一个专用的寄存器，用来专门“记住”这个cmp指令的比较结果的，而且，不仅是cmp指令，它还会自动记住其它一些指令的结果。这个寄存器就是：
eflags
“标志寄存器”，它的作用就是记住一些特殊的CPU状态，比如前一次运算的结果是正还是负、计算过程有没有发生进位、计算结果是不是零等信息，
   而后续的跳转指令，就是根据eflags寄存器中的状态，来决定是否要进行跳转的。
cmp指令实际上是在对两个操作数进行减法，减法后的一些状态最终就会反映到eflags寄存器中



循环
关键点 程序在往回跳转
如果程序每到一个位置就往前跳转，那就是死循环，如果是在这个位置根据条件决定是否要向前跳转，那就是有条件的循环了
c代码
```
int sum = 0;
int i = 1;
while( i <= 10 ) {
    sum = sum + i;
    i = i + 1;
}
```
翻译为汇编
```
global main

main:
    mov eax, 0   //sum
    mov ebx, 1   //i
_start:
    cmp ebx, 10      //与10比较
    jg _end_of_block //>10 退出
    
    add eax, ebx   //<=10  sum=sum+i
    add ebx, 1      //i+i
    jmp _start
    
_end_of_block:
    ret
```