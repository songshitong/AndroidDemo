header的name和value中看到的数字采用Huffman编码
  Huffman的索引值需要进行整型数字的编码，详见60讲

使用 5 位前缀：对小于 31 的整型数字的编码
当数字小于 31（2^5-1）时的编码     前3位保留，最大表示2的5次方-1=31
0 1 2 3 4 5 6 7    
? ? ?   value
例如：对10进行编码    10的二进制
0 1 2 3 4 5 6 7
X X X 0 1 0 1 0

Huffman静态表中 31以下是有key value的   31以上肯定是没有value的



使用 N 位前缀：整型的编码过程   非结尾第一个是1  结尾时第一个是0
 if I < 2^N - 1, encode I on N bits   
  else
   encode (2^N - 1) on N bits 
   I = I - (2^N - 1) 
   while I >= 128
     encode (I % 128 + 128) on 8 bits
     I = I / 128 
   encode I on 8 bits
   
 
使用 5 位前缀：对整型大数 1337 的编码举例 见图
 大于31时   先把31填上  x  x  x 1 1 1 1 1
 剩下1306   0-7位是2的8次方，最大128
   1306=128*10+26
   26+128=154  填入第二行 1 0 0 1 1 0 1 0
   对乘数10编码  1 0 1 0
   
   
 

整型的解码过程 
 第一行是31= 1 1 1 1 1
 第二行是 154-128=26
 第三行是 10
 结果 10*128+26+31=1337      
   
   


Aaaaaaaaaaayou
1337 明明直接可以用两个字节来编码，为什么要用这种方式编码呢，感觉更加消耗存储空间呀
作者回复: 这是从整型编码的主要应用场景出发设计的。静态表的使用概率最高，它的常用头部数字不到31，这时用一个字节就可以编码。算上动态表，头部数量通常也不过一百多，此时2个字节就可以编码。而且，首字节前3位还有很多逻辑含义，辅助动态表的使用。
如果是编码大数字，那么用这种方式，其实只是多浪费了第1个字节，后面的bit位利用率很高，达到了7/8，仍然可以接受。