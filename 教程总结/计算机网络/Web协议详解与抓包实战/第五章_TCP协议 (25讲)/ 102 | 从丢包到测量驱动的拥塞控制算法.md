2016 google提出bbr基于测量，对TCP的拥塞控制有巨大的性能提升

飞行中的数据与确认报文
  发送方向接受方发送数据时，大量的报文和ack数据在网络中
   网络中存在瓶颈路由器的概念，瓶颈路由器过载的时候，特别是等待队列全满的时候会出现丢包


大管道向小管道传输数据引发拥堵   瓶颈路由器怎么引发拥堵的
  发送方发送管道的流量非常大，但瓶颈路由器向接受方发送的管道特别窄，会造成大量的报文积压等待发送方
     接受方的管道很大，接受方的流量跑不满，接受方返回发送方的ack也跑不满
  
  当R1出现丢包时，有两个问题，报文的RTT很大，报文需要在发送方等待很长的时间
    第二个，整体的带宽，因为丢包导致的拥塞控制，进一步下降
  

传统拥塞控制的问题
  纵坐标是发送速率
    慢启动快速的上升，但实际的带宽没有那么大，很快发生丢包，之后进入快速重传，恢复，再次发送丢包
    RTT很高，带宽也没达到最高

linux2.6  cubic拥塞控制算法
  虽然非常平滑，但基于丢包来驱动，所以导致RTT非常大



最佳控制点在哪？ --1979 Leonard Kleinrock

• 基于丢包的拥塞控制点 基于丢包的问题
    • 高时延，大量丢包
    • 随着内存便宜，时延更高  内存便宜，路由器内存更大，缓冲更大
• 最佳控制点
    • 最大带宽下
    • 最小时延
    • 最低丢包率
• RTT 与 Bw 独立变化  测量最佳控制点时困难的
    • 同时只有一个可以被准确测量
  图片中随着带宽的上升，RTT是不变的，此时进程没有开足马力，等到达到最大带宽，路由器开始积压队列，此时RTT开始变大
  第二图y轴是带宽，一开始是上升的，然后带宽是不变的，图片1此时路由器积压队列，RTT变高，最后出现丢包
  传统的拥塞控制是在丢包的点进行的，理想的是在达到最大带宽的点开始控制，这个点可以享受最大带宽，最小时延，最低丢包率



空队列的效果最好！  核心目标
 缓存队列存在积压时，rtt也会增大


bbr拥塞控制对比图


BBR：TCP Bottleneck Bandwidth and Round-trip propagation time
 • 由 Google 于 2016 发布，Linux4.9 内核引入，QUIC 使用
 图中带宽波动上不去， bbr快速上升然后上不去


子杨
老师好，我有两个问题：
1. RTT 与 BW 独立变化是什么意思呢？同时为什么只有一个可以被准确测量？
2. 突然有一个想法，BBR 和 QUIC 都是针对服务器的吗？那咱们浏览器和移动端支持这些协议和算法吗？还是说需要这些终端去升级的？
   作者回复: 1、这是因为，RTT变慢时，BW吞吐量可以维持不变；同理，RTT不变时，BW可以升高或者降低。
   2、QUIT需要客户端也支持。BBR不需要终端，它只是采用不同的策略面对路由器上的缓存队列产生的拥塞