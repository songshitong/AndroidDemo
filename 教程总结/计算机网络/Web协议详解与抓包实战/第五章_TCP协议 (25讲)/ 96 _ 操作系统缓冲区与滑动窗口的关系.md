

窗口与缓存
 • 应用层没有及时读取缓存
  第2步进程读取了40字节，剩下的100留在系统缓冲区中
  接受窗口260  tcp中window260发给client
  第五步 假设进程仍然没有读取新的180  接受窗口80
  第8步  window为0，也叫窗口关闭


收缩窗口导致的丢包
 • 先收缩窗口，再减少缓存
 • 窗口关闭后，定时探测窗口大小   窗口关闭后，不能一直等待server的，可能server的不再发送报文了或者ack发送完毕，client
    主动发送探测报文，确定窗口大小，server窗口从0变为正向的打开，client可以知道

 第2步 服务器缓存收缩，200个进程变为500个进程，每个进程或TCP链接的缓存降低
   接受窗口变为100
   第2步的window改变和ack要很久client才能收到，第5步
 
 第4步收到180字节，但是接受窗口只有100，多余的丢掉
 第5步 
   client收到180的确认，发送窗口只有100字节，此时发送窗口左移80
   
  实际操作系统不会让这种情况发生的，不会发生又收缩缓存又收缩窗口的情况，一般先收缩窗口，过段时间后再收缩缓存



飞行中报文的适合数量
 • bps*RTT    带宽*时延   带宽时延积


Linux下调整接收窗口与应用缓存    应用缓存和接受窗口占据缓存的比例
net.ipv4.tcp_adv_win_scale = 1
 应用缓存 = buffer / (2^tcp_adv_win_scale)



Linux中对TCP缓冲区的调整方式
• net.ipv4.tcp_rmem = 4096 87380 6291456
   • 读缓存最小值、默认值、最大值，单位字节，覆盖 net.core.rmem_max
• net.ipv4.tcp_wmem = 4096 16384 4194304
   • 写缓存最小值、默认值、最大值，单位字节，覆盖net.core.wmem_max
• net.ipv4.tcp_mem = 1541646 2055528 3083292     操作系统压力大，进程从100变为1000，内存已经非常紧张了，可以缓冲区调小一点，进程少，连接数少的，缓冲区调大一点
   • 系统无内存压力、启动压力模式阀值、最大值，单位为页的数量
• net.ipv4.tcp_moderate_rcvbuf = 1
   • 开启自动调整缓存模式




Geek_1386e9
老师，请问一下如果调用setsockopt()设置了socket选项SO_SNDBUF，那么tcp缓冲区的动态调整还有效吗
作者回复: 无效


Jee
老师这节课有个疑问 BPS*RTT 这样RTT越大 接收窗口越大么？
作者回复: 是的，相同带宽下，如果RTT越大，那么应当配置更大的缓冲区，以允许TCP使用更大的滑动窗口


tongmin_tsai
老师，关于缓冲区这块，是操作系统所有的连接共用，还是每个连接单独分配缓冲区？
作者回复: 连接单独拥有



 