当TCP的segment的数据量小，只有几个字节时，整个网络的传输效率是非常低的，每个segment都有固定的20字节的TCP头，20个字节的IP头部，
所以整个报文中有效信息的比重非常低，我们应当在合理的范围内避免大量传输小报文


SWS(Silly Window syndrome)糊涂窗口综合症
 • 小窗口通告
   假设server非常繁忙，每次发送的报文逐步减少，窗口也减少
     应该等待server把报文处理完成，再发送后续报文，避免往复的小报文发送，这样TCP效率非常低效



SWS 避免算法
• 接收方   窗口移动太小了
      • David D Clark 算法：窗口边界移动值小于 min（MSS, 缓存/2）时，通知窗口为 0
• 发送方
   • Nagle 算法：TCP_NODELAY 用于关闭 Nagle 算法
      • 没有已发送未确认报文段时，立刻发送数据
      • 存在未确认报文段时，直到：1-没有已发送未确认报文段，或者 2-数据 长度达到 MSS 时再发送
      图片中使用Nagle算法发送hello
       h属于没有未确认报文，立即发送  等待收到ack属于第一种情况(1-没有已发送未确认报文段)，然后立即发送
       ell和o相同

https://zhuanlan.zhihu.com/p/359177898
Nagle 算法其实是个有些年代的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，
这样的包立马就发出去了，会导致网络由于太多的包而过载
今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，
你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。
所以现在一般也会把它关掉

TCP delayed acknowledgment 延迟确认     ack的效率也很低，只是一个ack，但有固定的头部
• 当有响应数据要发送时,ack 会随着响应数据立即发送给对方.    减少ack的RTT
• 如果没有响应数据,ack 的发 送将会有一个 延迟,以等待看是否有响应数据可以一起发送
• 如果在等待发送 ack 期间,对方的第二个数 据段又到达了,这时要立即发送 ack

图片是 Linux4.9的等待时间   HZ 与时钟频率有关，每个系统不一样
TCP_DElACK_MIN 最短等待时间
TCP_DElACK_MAX 最长
cat /boot/config-`uname -r` | grep '^CONFIG_HZ'
CONFIG_HZ_1000=y
CONFIG_HZ=1000
此时最长是200，最短是40ms

nagle delay的问题
发送小报文h后要等500ms才发送后续的ello  这样网络效率同样很低


Nagle VS delayed ACK  解决nagle算法一定存在的delay
• 关闭 delayed ACK：TCP_QUICKACK
• 关闭 Nagle：TCP_NODELAY


Linux 上更为激进的”Nagle”：TCP_CORK  所有都是大的报文，
• 结合 sendfile 零拷贝技术使用   使用场景限制，结合sendfile使用
  普通文件读取先从磁盘复制到内核的用户态，然后发给tcp的缓冲区，经过发送窗口发给client
  sendfile直接由内核把磁盘中的文件读入到TCP的发送缓冲区，直接进行发送，减少了两次拷贝


粘包和拆包  https://juejin.cn/post/6988794419910541348
TCP是面向流，没有界限的一串数据。TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，
一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题

为什么会产生粘包和拆包呢?
要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。
  
解决方案：
发送端将每个数据包封装为固定长度
在数据尾部增加特殊字符进行分割     在包尾部增加回车或者空格符等特殊字符进行分割，按行解析，遇到字符\n、\r\n的时候，就认为是一个完整的数据包
将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小

https://zhuanlan.zhihu.com/p/359177898
可能这时候会有朋友会问，采用0xfffffe标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？
是的，怕，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（校验和或者对整段完整数据进行 CRC 之后获得的数据）放在标志位后面，
在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据

//todo完善问题和答案
为什么UDP要冗余长度字段？
udp数据放在Socket Buffer，如果消息没有及时取走，需要区分消息的边界
增加长度字段

udp存在粘包吗？
不存在
IP存在粘包吗？
不存在



加载中……
老师好，请教个问题，从课程内容看：
TCP_CORK：是为了不发送小报文，从而提高传输效率
sendfile零拷贝：是不经过用户态空间，直接在内核中进行，节省了时间和空间
1、感觉sendfile和TCP_CORK没太大关系
2、还有在配置的时候是必须打开sendfile零拷贝功能，才能启用TCP_CORK么？
作者回复: 1、内核需要均衡发送窗口中的可用窗口与待发送文件内容，对于应用程序来说没有影响，但对于内核的行为是有影响的。
2、是的。