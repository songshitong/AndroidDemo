
当丢包时，将重新执行慢启动，此时意味着拥塞窗口大幅度下降，发送速率也会大幅下降，当丢包不是很严重时，可以使用快速重传和恢复。



为何会接收到一个失序数据段？   pkt1丢失，对于receiver来说pkt2就是失序报文,因为pkt0-pkt2存在pkt1,这就叫做失序数据段
• 若报文丢失，将会产生连续的失序 ACK段
• 若网络路径与设备导致数据段失序，将会产 生少量的失序 ACK段   网络路由器很可能基于不同的端口，队列不一样，最后导致没有丢包，很是顺序发生错乱，会产生少量的ack
• 若报文重复，将会产生少量的失序 ACK段
   拥塞控制主要解决第一种情况


快速重传（RFC2581）
• 接收方：
    • 当接收到一个失序数据段时，立刻发送它所 期待的缺口 ACK 序列号         收到pkt6,发现pkt5丢失，发送ack5
    • 当接收到填充失序缺口的数据段时，立刻发 送它所期待的下一个 ACK 序列号   收到pkt3,发送ack4
• 发送方
    • 当接收到 3 个重复的失序 ACK 段（4 个相同 的失序 ACK 段）时，不再等待重传定时器的 触发，立刻基于快速重传机制重发报文段
      重传定时器可能等待很长时间


超时不会启动快速重传
  必须接收到 3 个重复的失序 ACK 段


快速重传下一定要进入慢启动吗？  不一定
• 收到重复 ACK，意味着网络仍在流动
   • 慢启动会突然减少数据流




快速恢复（RFC2581）
• 启动快速重传且正常未失序 ACK 段到达前，启动快速恢复
    • 将 ssthresh 设置为当前拥塞窗口 cwnd 的一半，设当前 cwnd 为 ssthresh 加上 3*MSS
    • 每收到一个重复 ACK，cwnd 增加 1 个 MSS     线性增加
    • 当新数据 ACK 到达后，设置 cwnd 为 ssthresh



胡波 allenhu
老师， 在接收端，是不是只要当他收到的包中的sequence number和接收窗口中的rcv.nxt一样的情况下，接收端才会把ACK中的acknowledge number更新为rcv.nxt的值。如果不一样，那么acknowledge的值就一直不变。这样在发送端在连续收到ACK中发现acknowledge number没变，就可以断定某个包接收端没有收到，从而可以快速重传这个包？
作者回复: 是的


Lengend
老师，您好，请教您两个问题，望您解惑，谢谢！
1、为什么会出现连续收到3个ack报文的情况 ，既然已经收到1个了，为什么还会继续收到剩下的两个？
2、因为发送方发送tcp报文段，是并发发送的（tcp优化章节），所以有可能会出现pk4早于pk3被接收方收到，那接收方怎样判断失序的？
3、收到三个ack后，接收端要马上发送下一个期望的ack，下一个期望的ack是指发送方已发送报文，但还没有收到的最近的一个ack，如ac9（ppt图片中没有画发送pk9，确认下）
作者回复: 1、中转路由器可能出现重启、队列满丢包、变更网络路径等，所以会出现重复报文。
2、TCP报文段都有sequence，接收方凭这个字段来判断是否失序；
3、是的。
后两个问题都靠sequence字段的设计解决。但这个设计也导致了基于TCP的多路复用协议出现队头阻塞，所以http3才选择抛弃tcp


Hurry
例子中都是丢了一个数据包的情况，连续丢多个数据报，接收方如何返回ack序列号？
作者回复: 每次仍然返回应收、但未收到的sequence

kissingers
老师，快速恢复后为什么cwnd 为ssthresh加3MSS，规定吗？又是出于什么考虑？谢谢
作者回复: 基于当时调研过的网络环境的经验数据



子杨
老师好
1. 接收方立刻发送它所期待的下一个 ACK 序号，例子中发送了 ACK9，那么针对报文 pkt6/7/8 的 ACK 确认什么时候发？还是说重复发的 ACK5 就相当于确认了？
2. 快速恢复中，为什么当新数据 ACK 到达后，设置 cwnd 为 ssthresh 呢？这时候不是已经恢复了吗，怎么拥塞窗口反而降低了。
3. 报文重复的意思是说，接收方收到了，但是发送方没有收到 ACK，所以发送方又重发了？
   作者回复: 1、TCP的序列号是连续的，所以收到ACK9，就相当于6、7、8也确认了。
   2、重新看了下，其实你的问题是，为什么快速恢复中cwnd会超过ssthresh。 因为，ssthresh在发生快速重传时，减为cwnd/2，这是最终目标，原因是发生了丢包，所以要减速。但为什么快速恢复中，cwnd会超过ssthresh呢？这是因为，此时网络不是那么差，还能够收到ACK，也许只丢了窗口中最早的那一个报文，如果不允许cwnd超过ssthresh，那么重发第一个报文再等到ACK，就是一个RTT的时延，这太长了。所以允许在这个过程中cwnd超过ssthresh，这仍然能保持着速度不会降得太快。但结束后已经没有丢包了，还是得回到最初的目标，把速度降下来，防止再次丢包。
   https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_WANIDA/DR/JavisInActionFastRecoveryFrame.html，这篇文章解释得很清楚，你可以看下。

3、网络中是会重复发送报文的，比如某个路由器出现故障。

